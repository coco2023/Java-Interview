在技术面试中，如果跟面试官聊到“项目中分库分表”这个话题，面试官往往会有如下夺命四连问：

1.  项目中业务主表的数据达到多少量级，就需要做分库分表了？
1.  说下分库分表的方式及适用场景。
1.  分库分表的挑战点有哪些？
1.  你项目中是如何做分库分表的？为什么要这么做？


下面我们来一一进行分析讲解。




## 单表数据量级

关于单表的数据承载量，网上流传着这样一种说法：`单表数据量级不要超过两千万，否则就要进行分库分表了`。

那么这种说法到底有没有根据呢？我们从数据库的底层原理来分析一下。


MySQL 的 InnoDB 存储引擎的**数据页（Page）** 是磁盘管理的最小单元，也是磁盘 IO 的最小单元，大小为 `16k`。


数据页结构如下：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88f1d318cac84fc59bdaa57a4853ced9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=408&h=377&s=35473&e=png&b=ffffff" alt=""  /></p>


-   File Header，38 字节，描述当前页通用的状态信息。
-   Page Header，56 字节，描述数据页特有的状态信息。
-   Infimum、Supremum，26 字节，代表了当前页中最大（Supremum）和最小（Infimum）记录。其作用为，在目标记录查询时，无需将整页的 `User Records` 全部进行遍历，只需比较 Supremum 和 Infimum 即可。
-   **User Records，这个属性比较关键，因为它是实际存储用户的记录数据**。
-   Free Space，页中尚未使用的空间。
-   Page Directory，页中记录数据的相对位置。
-   File Trailer，8 字节，用于检验当前页的完整性。



综上所述，数据页中除 User Records 外的属性占用空间很小，基本上都是用于用户记录数据的存储。

我们假定单条用户记录大小为 1k，那么一个数据页可以存储 16 条记录数据，该数据页存储在 B+ 树的叶子节点中。非叶子节点的数据页则存储主键 ID + 指针，业务主表的主键 ID 通常为长度 8 字节的 bigint 类型，指针大小为 6 字节，共 14 字节。


那么一个 16k 的数据页，就可以存储 *16384 / 14 = 1170* 个主键 ID + 指针的键值对。那么可以推算出，高度为 2 的 B+ 树能存放 *1170（存储主键 ID + 指针的数量） * 16（记录数） = 18720* 行记录，高度为 3 的 B+ 树能存放 *1170 * 1170 * 16 = 21902400* 行记录 *。*


如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/580c64746a9f48b6b6c4fb781da3e682~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=694&h=391&s=49497&e=png&b=fefefe" alt=""  /></p>


如果单条用户记录大小为 512b，那么一个数据页可以存储 32 条记录数据，那么高度为 3 的 B+ 树可以存储 *1170 * 1170 * 32 = 43804800* 行记录。


一旦超出范围的话，B+ 树的高度就会从 3 变成 4，也就是说，By ID 查询的磁盘 IO 次数从 3 次变成 4 次，多增加了一次磁盘 IO，增加了性能消耗。

因此，“数据量级达到两千万需要进行分库分表”的说法，还是有其一定理论根据的。




## 方式及适用场景

分库和分表所要解决的`共性问题`在于，**将数据量庞大的业务主表进行拆分，解决高并发场景下数据查询或写入缓慢的问题**。


不过，两者的各自适用场景还是有所`区别`的。

-   **分库**：当数据库服务器的`硬件资源`成为瓶颈的情况下，可以选择分库方案，比如：CPU 使用率 100%，IOPS 和 Load 过高，网卡被打满，等等。
-   **分表**：当数据库服务器的硬件资源不是瓶颈，而数据库中的`锁`成为瓶颈的情况下，可以选择分表方案。虽然 MySQL 中的锁有很多，但除了全局锁之外，其他类型的锁都可以通过分表来缓解锁冲突的。

数据库中的锁类型，如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ac7a568adb44261bb6ab269b3f691ba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=352&s=81629&e=png&b=fffdfd" alt=""  /></p>


另外，分库分表，按其拆分的方式不同，又分为**水平拆分**和**垂直拆分**。

> btw：分库和分表从操作上大同小异，都是先进行分表，只不过分库会将拆分后的表，放到不同的数据库服务器上。





### 水平拆分

如上文所说，一张表内的数据一旦超出几千万范围的话，B+ 树的高度和磁盘 IO 次数就会从 3 变成 4，性能会变差，所以通过水平拆分的方式，将其一分为 N，这样可以保持原有的性能。

举个例子：我们要对比较常见的 user 表进行水平拆分，于是便创建了跟 user 表结构一模一样的 N 张表，即：user_0，user_1，....，user_n，然后根据水平拆的策略，将 user 表中的数据迁移到这些分表中去。


如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b7f50c3fec249feb278d821292b2902~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=690&h=346&s=54905&e=png&b=ffffff" alt=""  /></p>



当然，硬币的两面性，一旦进行了水平拆分，就会带来查询和排序复杂化的问题，所以还需要合理的拆分策略，可以将问题的影响降至最低，这点很重要。


### 垂直拆分

就是在业务主表中，把一些不常用的字段或大字段拆分出去，拆分后的业务主表的数据记录更小，一个 16k 的数据页就可以存储更多数据。


举个例子：user 表中的姓名、性别和年龄字段占用的空间较小，但地址和履历字段占用的空间很大，且访问频率较低。那么我们就竖切一刀，把 user 表中的地址和履历单独拆分出去，为其创建一张新的表来进行存储。

如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/421e4c750be849819cb15b975ee1b612~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=611&h=383&s=50187&e=png&b=ffffff" alt=""  /></p>


我们当然希望拆分出去的字段，既是大字段，而且访问频率还很低。但如果拆分出去的字段，总是跟业务主表的字段 join 在一起“出双入对”的话，那其实拆分的价值也就不大了。







## 挑战点

### 水平拆分的策略

水分拆分需要考虑的因素有三个：

-   **查询操作中的路由因素**；
-   **插入操作中的热点分散因素**；
-   **技术方案的复杂度因素**。

并且，这三种因素间是一种**零和关系**，两方所得必为一方所失，这无疑为选择和取舍增加了难度。

基于如上三种因素考虑，共有四种水平拆分策略，即：`Range 拆分`、`Hash 取模拆分`、`Hash 取模 + Range 拆分`和 `Hash 取模 + 映射表拆分`。




#### Range 拆分

最常见的就是以`日期`作为 Sharding Key（分片键），进行 Range 拆分。

图例如下：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e91d8582c12c4d1b9a5229888ce609f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=521&h=353&s=25893&e=png&b=ffffff" alt=""  /></p>


- 优点：非常适合于存储**冷热分明的业务数据**，几乎所有查询操作全部在热数据表中完成，而冷数据则是以半归档的方式进行存储。

- 缺点：热点数据全部集中在一张表中，在高并发的场景下容易产生性能瓶颈。



#### Hash 取模拆分

最常见的就是以 `ID` 作为 Sharding Key，通过取模的方式拆分，如：主键 ID、用户 ID、商家 ID、课程 ID 等。

图例如下：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bec3d2674b8c47568ba351f03c325b1f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=530&h=373&s=35052&e=png&b=ffffff" alt=""  /></p>


- 优点：无论是分库还是分表，热点数据都已经全部散开，可以从容应对高并发的场景，不会产生性能瓶颈。

- 缺点：对非 Sharding Key 的查询操作不友好，只能将所有库表全部查询一遍，然后再进行多路归并的方式返回结果。




#### Hash 取模 + Range 拆分

最常见的就是：先以 ID 作为 Sharding Key，通过取模的方式进行首次拆分；然后再以日期作为 Sharding Key，进行 Range 二次拆分。其实就是上述两种方案的的结合体。

图例如下：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9476330adcf44df8d72934bfe576874~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=689&h=355&s=32825&e=png&b=fefefe" alt=""  /></p>


优点：

- 取模拆分的方式，无论是分库还是分表，热点数据都已经全部散开，可以从容应对高并发的场景，不会产生性能瓶颈。
- Range 拆分的方式，使单表数据量级得到很好的控制，而不是随着时间的推移，表中的数据越累积越多。

缺点：

- 对非 Sharding Key 的查询操作不友好，只能将所有库表全部查询一遍，然后再进行多路归并的方式返回结果。
- 相较而言，方案过于复杂。



#### Hash 取模 + 映射表拆分

最常见的就是以 ID 作为 Sharding Key，通过取模的方式拆分，然后再通过映射表的方式进行辅助查询。

图例如下：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f9297cccd8e4a21b2c92717603a66ff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=689&h=392&s=34312&e=png&b=ffffff" alt=""  /></p>

优点：

- 无论是分库还是分表，热点数据都已经全部散开，可以从容应对高并发的场景，不会产生性能瓶颈。
- 通过映射表辅助的方式，可以灵活地构建一对多的查询关系，并且只需要根据映射表关系查询目标库表即可，不需要所有库表全部查询一遍。


缺点：

- 对非 Sharding Key 的查询操作不友好，只能将所有库表全部查询一遍，然后再进行多路归并的方式返回结果。
- 方案过于复杂，且映射表数据量过大，也需要考虑分库分表的可能性。



### 垂直拆分的动态化

我们需要以动态的眼光看待垂直拆分。

举一个电商场景中商品中心的 case：某研发团队把商品列表页需要的字段保留在了业务主表里，商品列表页不需要、但商品详情页需要的字段，拆分到了另一个表里，里面有类似于“商品描述”的大字段，还有一些“无理由退换货”“晚到必赔”等售卖规则的小字段。

似乎一切看起来都很完美。

忽然有一天，产品经理改了需求，需要把“无理由退换货”的售卖规则前置到商品列表页进行展示。

如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49693e966fbb41299d7bbf6b97e64eb8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=1558&s=811996&e=png&b=faf6f5" alt=""  width="70%"/></p>



<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d7c4cf9bf1c401d9c748d472ebe54a3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=1558&s=746926&e=png&b=f7efed" alt=""  width="70%"/></p>



这种情况就会变得非常棘手，如果想保持原来的性能，就必须把这些售卖规则迁移到业务主表中。

如果不想这么大动干戈，那么就必须接受售卖规则这些小字段，必须和“商品详情”类的大字段一起进行磁盘 IO，这将对读取性能造成较大影响。

因为 MySQL InnoDB 中的最小 IO 单元是数据页，而每个数据页会存储若干行记录中的所有字段。

因此，我们在进行垂直拆分的时候，必须要考虑到后续业务的动态变化，而不是以一成不变的眼光进行分析设计。


### 容量预估的前瞻性

我们希望把分库分表的策略一次性做到位，让其至少可承载未来五年的数据量级，而不是由于容量预估不足，导致时隔一年半载地再重来一遍。

因此，在容量预估上，我们不能局限在线性思维中，认为今年业务主表的数据量是 5000 万，那么明年还是 5000 万，而是要把业务增量也考虑进去，这样才算是具备前瞻性的容量预估。



## 总结

本章我们把分库分表中最高频的三大面试问题过了一遍，以增加你对这个方向的技术知识储备，用以扛住面试官的夺命三连问。 

对于该方向和类型的问题，关键点在于，首先要对业务领域有全面透彻的理解，并且对于其未来的业务变化具备高度前瞻性，这样才能产出最为合理的设计方案。 

后两章我们会以真实的业务场景进行带入，通过理论结合实践的方式深入讲解。