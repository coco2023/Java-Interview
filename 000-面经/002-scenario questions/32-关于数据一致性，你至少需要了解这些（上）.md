在面试过程中，候选人经常被面试官考查的技术问题，除了三高一海（高并发、高可用、高性能、海量数据）以及研发提效这五大方向之外，还有一大高频方向也是神一般的存在，那就是“数据一致性”的问题。


## 面试场景

面试官：“可以说下你们具体的业务场景吗？”

候选人：“我们是在线教育平台的大班课业务场景，用户选好了课程并下单购课，当课程订单付款成功后，就会通知下游的班课系统对其进行组班和排课操作。”

面试官：“那你们的系统采用的是单体架构还是微服务架构？”

候选人：“由于我们系统中的功能模块越来越复杂，且项目组的研发人员也越来越多，已经从最初的单体架构演进成的微服务架构。”

面试官：“微服务架构下，每个服务的库表应该是相互独立的。那你说下，你项目中的跨服务写操作，是如何保证数据一致性的？”

候选人：“我们是通过分布式事务的方式来保证数据一致性的。”

面试官：“那可以说下，你们用的是哪种分布式事务吗？是刚性事务还是柔性事务？”

候选人：“抱歉，我对刚性事务和柔性事务不太了解，我们用的是本地消息表的方式来实现的。”

面试官：“为什么用本地消息表的方式实现，当时是如何进行技术选型的呢，可以说说吗？”

候选人：“这个，当时是团队内的系统架构师进行技术选型的，我不太能清楚其中的具体细节。”

我们从以上技术面试场景中可以看出来，很多候选人都知道通过分布式事务的方式，来解决微服务架构下的数据一致性问题。但往下深挖的话，却不清楚如何对各个分布式事务方案进行技术选型。

接下来就带着大家，对常见的分布式事务方案进行深入剖析。


## 分布式定理

### CAP 定理

在一个分布式系统中，最多只能在`一致性（Consistency）`、`可用性（Availability）`和`分区容错性（Partition tolerance）`中三者满足其二，不能同时满足这三项。

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/386ca5da4e564abcb15b2e71f981b0e8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=386&h=322&s=37696&e=png&b=ffffff" alt=""  /></p>



**一致性（Consistency）**，all nodes see the same data at the same time，按照原文翻译是：在同一时刻，分布式系统中所有节点中的数据是完全一致的。

我们也可以引申理解为“分布式系统的业务逻辑一致性”。

举个例子：用户 A 给用户 B 转账 100 元，那么在任何时刻，我们都必须能够同时看到用户 A 的账户少了 100 元，用户 B 的账户多了 100 元。

一致性分为强一致性、弱一致性和最终一致性。

-   强一致性，业务结果中的每个步骤，在“任何时刻”都同时生效。CAP 定理中所说的一致性就是强一致性，上述例子中所描述的也是强一致性。
-   弱一致性，不能保证业务结果中的每个步骤，在“任何时刻”都同时生效。
-   最终一致性，经过一段时间以后，业务结果中的每个步骤都会最终生效。

**可用性（Availability）**，reads and writes always succeed，按照原文翻译是：任何时候，分布式系统的读写操作都是成功的。

也就是说，在规定时间内，分布式系统对接收到的每个用户请求，都可以返回正常的业务结果。

**分区容错性（Partition tolerance）**，the system continues to operate despite arbitrary message loss or failure of part of the system，这个说得比较绕一些。

我们可以这样理解，当分布式系统遇到网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。

### BASE 定理

BASE 定理是对 CAP 定理中 AP 方案的延伸，旨在通过最终一致性的方式来替代 CAP 定理中的强一致性。

> BASE 定理 = 基本可用（Basically Available）+ Soft state（软状态）+ Eventually consistent（最终一致性） 

- **基本可用**，当分布式系统出现不可预知故障的时候，允许损失部分可用性，保证其核心功能可用。

- **软状态**，允许分布式系统中的数据存在中间状态，且该中间状态的存在不会影响系统的整体可用性。

- **最终一致性**，经过一段时间以后，分布式系统能够达到业务逻辑一致性的状态。

如上述面试场景所述，分布式事务分为刚性事务和柔性事务两种，其中刚性事务满足于 CAP 定理中 CP 的要求，而柔性事务则符合 BASE 定理。



## 分布式事务

分布式事务的详细分类，请见下图：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2dda84d143b4226897cf6654611d41e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=668&h=390&s=39872&e=png&b=fffbfb" alt=""  /></p>



可以看到，在柔性事务中又分为补偿型和通知型，补偿型事务都是以同步 RPC 调用的方式实现的，而通知型事务则是以异步 MQ 通知的方式实现的。

下面我们就来一一详聊每个分布式事务方案。


### 2PC

顾名思义，将事务进行两阶段提交，第一个阶段为事务预提交阶段，第二个阶段为事务提交或回滚阶段，由事务协调者对所有的事务参与者进行整体协调把控。

**1. 事务预提交阶段**

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7903592c6ca84dbc9f8c4975b5620419~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=401&s=65836&e=png&b=ffffff" alt=""  /></p>



如上图描述：

（1）事务协调者向所有事务参与者发起询问指令，是否可以提交事务。

（2）各事务参与者进行预提交事务，记录数据库 Redo Log 和 Undo Log。

（3）各事务参与者向事务协调者返回结果（ACK 或 Abort）。


**2. 事务提交或回滚阶段**

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d5871744076405fad50a1abce9f5880~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=585&h=357&s=45181&e=png&b=fefefe" alt=""  /></p>



如上图描述：

（1）事务协调者会根据阶段一中的执行结果（ACK 或 Abort），向所有事务参与者发起提交或回滚事务的指令。

（2）各事务参与者进行提交或回滚事务，并释放事务执行期间占用的相关资源。

（3）各事务参与者向事务协调者返回 ACK，全部返回后即完成事务。

2PC 的实现原理比较简单，但其存在几个致命缺点：

（1）**中心化单点问题**，事务协调者一旦挂了，所有事务参与者接收不到“阶段二”中的提交或回滚事务的指令，全部处于进退两难的中间状态，既无法释放被锁定的数据库资源，也无法完成事务的终态操作。

（2）**数据一致性问题**，在“阶段二”中，事务协调者会向所有事务参与者发起提交或回滚事务的指令，若此时出现了局部网络异常，部分事务参与者没有收到指令，就会出现数据一致性的问题。

（3）**性能问题**，在整个事务执行期间，所有事务参与者的数据库资源都处于被锁定的状态，对性能影响较大。

针对于 2PC 所存在的几个缺点，3PC 分布式事务方案应运而生了。

### 3PC

3PC 作为 2PC 的改进版本，有如下两个改动点：

（1）2PC 只有事务协调者才有超时机制，而 3PC 中的事务参与者也具备了超时机制，可在超时后自动提交事务，释放被锁定的数据库资源。

（2）3PC 将 2PC 中的第一阶段（事务预提交阶段）拆分为两个阶段，事务询问（CanCommit）阶段和事务预提交（ PreCommit）阶段，旨在以前置询问的方式快速失败，减少事务的阻塞时间。

**1. 事务询问阶段**

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e11ea391453545e4a745adcc7155eda3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=548&h=383&s=37753&e=png&b=ffffff" alt=""  /></p>



如上图描述：

（1）事务协调者向所有事务参与者发起询问（CanCommit）指令，是否可以提交事务。

（2）各事务参与者向事务协调者返回结果（ACK 或 Abort）。

**2. 事务预提交阶段**

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f9e25e9aa974e6f86dfc47c04295b9f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=590&h=352&s=46645&e=png&b=fefefe" alt=""  /></p>



如上图描述：

（1）事务协调者会根据阶段一中的执行结果（ACK 或 Abort），向所有事务参与者发起预提交或中断的指令。

（2）前者的逻辑为，各事务参与者进行预提交事务，记录数据库 Redo Log 和 Undo Log，并返回结果（ACK 或 Abort）。

**3. 事务提交或回滚阶段**

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41f1dc377b94441a9b2c70deb434b7aa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=585&h=357&s=45181&e=png&b=fefefe" alt=""  /></p>



如上图描述：

（1）事务协调者会根据阶段二中的执行结果（ACK 或 Abort），向所有事务参与者发起提交或回滚事务的指令。

（2）各事务参与者进行提交或回滚事务，并释放事务执行期间占用的相关资源。

（3）各事务参与者向事务协调者返回 ACK，全部返回后即完成事务。

相较于 2PC，3PC 解决了释放被锁定的数据库资源，以及减少事务的阻塞时间的问题，但同样引入了新的问题。

那就是，其释放被锁定的数据库资源，是通过超时后自动提交事务来实现的。这也就意味着，“提交事务”这个动作并不是事务协调器发起的，而是其“自作主张”的。

我们假设一种场景，在阶段三中，事务协调器发送了 Abort 指令，事务参与者 1 收到指令并执行了回滚操作，而事务参与者 2 并没有接收到该指令，超时后自动提交了事务，还是会出现数据一致性的问题。


## 总结

在本文中，我们以一个技术面试场景开头，先是介绍了分布式定理中的 CAP 定理 和 BASE 定理，然后又对分布式事务进行刚性和柔性归类，并介绍了其中的刚性事务（2PC、3PC）。

在下文中，我们会继续介绍柔性事务，以及各事务相关的适用场景。