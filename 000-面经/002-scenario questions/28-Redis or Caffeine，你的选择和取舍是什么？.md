在技术面试中，我发现这样一种情况，一旦候选人在项目中用到了 Caffeine 或 Guava Cache 类的本地缓存，那往往会引起有些面试官的夺命 N 连问：

- 为什么在项目中用 Caffeine 本地缓存，而不使用 Redis 这种集中式缓存，你的考量是什么？
- 当数据发生变更的时候，你是如何清理或修改 Caffeine 本地缓存的？
- 如果你的应用服务器发布上线新功能，导致 Caffeine 本地缓存被清空了，会不会此时数据库所承载的压力非常大啊？
- 你在 Caffeine 本地缓存中存储这么多数据，会不会导致频繁 Mixed GC 或 Full GC 的情况出现啊？

其实，也不能怪面试官有这么多疑问，毕竟在 90% 的业务场景中，我们都可以无脑地选择 Redis，这是一个非常主流的技术方案。

但从另外的一个角度上讲，Caffeine 本地缓存这个东西存在即合理，如果我们可以跟面试官讲清楚为什么选择它，且逻辑自洽的话，又会是一个大大的加分项。

下面我们就来通过一个实际场景来进行说明，看看 Caffeine 本地缓存的适用场景。



## 实际场景之 —— POI 服务

某用户量几亿级别的大型本地生活类电商平台，其中有一个 QPS 极高且极为关键的服务 —— POI 服务。

POI，Point of Interest 的缩写，在本地生活类电商平台上指的是，任何公开经营且符合网站收录范围的商户。POI 服务承载着各业务线系统对于商户信息的查询请求，QPS 峰值过万。

该 POI 服务属于一个偏底层的服务，会被上游的 N 个系统进行调用，如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e142379520046d4b59a3f664bbe6f12~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=719&h=346&s=49576&e=png&b=ffffff" alt=""  /></p>



POI 服务存储的商户信息包括：商家名称、整体介绍、电话、所在城市、地址、经纬度、营业时间、设施及服务、商家事记等 30 多个字段。其中，有几个类似于整体介绍和商家事记这样的大字段。

该本地生活类电商平台共有 400 多万条 POI 数据，每条 POI 数据的平均大小为 1.3K， 整体大小为 6 个 G 左右。

我们从提升系统性能、减少 MySQL 数据库访问压力的角度考虑，已经将 POI 数据全部存储在 3 主 3 从的六台 Redis Cluster 服务器中。


### POI 数据量过大问题

目前系统的最大瓶颈点在于 Redis Cluster 服务器的网络上，由于上游系统的请求多是以批量的方式来获取 POI 数据的，平均每次请求数据的大小为 1M，那么即使 Redis Cluster 的服务器用的是万兆网卡，但在过万 QPS 的请求峰值下，依然会出现 Redis 服务器的网卡被打满的情况。

btw：万兆网卡理论上的最大传输速度为每秒钟 1280MB，由于 3 主 3 从的 Redis Cluster 只有三个主库在接收并响应用户请求，因此该 Redis Cluster 理论的最大网络容量为每秒 3840M。而在 QPS 峰值过万，且单请求数据的大小为 1M 的情况下，需要的网络容量为每秒 10000M，约等于 10 个 G。

在这种情况下，我们可以选择无脑地给 Redis Cluster 进行扩容，直接将 3 主 3 从扩容到 12 主 12 从，一步到位的同时，也预留了 50% 网络容量。

除此之外，我们也可以考虑一些新的技术解决方案，比如：引入 Caffeine 本地缓存来构建多级缓存策略，通过现有的 12 台应用服务器去满足每秒 10 个 G 网络容量。

如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ddf795c602e4b668b80c7f96e8ee5b7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=683&h=186&s=23800&e=png&b=ffffff" alt=""  /></p>



不过，Caffeine 本地缓存不同于 Redis Cluster，需要将 6 个 G 的全量 POI 数据全部存储在每台应用服务器的集群中，这对 4C8G 的应用服务器来讲，显然是力不从心的。并且，每次应用服务器发布新的业务需求上线，都需要重新进行 POI 数据的预热加载的话，也需要执行很久的时间才行，根本不现实。

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c9d1a6c82ff4d5a9fe92476414bcfae~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=630&h=409&s=32391&e=png&b=ffffff" alt=""  /></p>



其实解决起来也很简单，因为 POI 数据并不是均分流量的，而是存在高度倾斜性。每个城市 1% 的热门 POI 数据，会承接 90%+ 的请求量。

换言之，我们只需要通过标签筛选的方式，将这 1% 的热门 POI 数据加载进 Caffeine 本地缓存即可。这样，我们只需要集群中的每台应用服务器 60M 的存储空间就可以了。



### POI 数据变更问题

虽然 POI 数据变更频次较低，但并不代表其永远不会进行变更。而使用 Caffeine 本地缓存的另一个麻烦之处在于，该 POI 数据遍布在集群中的每个应用服务器上，进行主动变更比较麻烦，需要实现类似于 “广播机制” 或 “发布订阅机制” 才可以。

但 “广播机制” 或 “发布订阅机制” 实现起来太麻烦了，我们继续从 POI 数据的业务特征入手，寻求新的技术解决方案。

我们选定的策略是，由于 POI 数据对实时性要求并不高，所以将其从“主动变更机制”更改为“被动过期机制”。即：每条 POI 数据都会设置上一个 8 秒到 12 秒之间（中位数是 10 秒）的过期时间，该条 POI 数据过期后会，会随着用户请求自动从 Redis Cluster 中加载新的数据。

```java
Random random = new Random();
int randomNumber = random.nextInt(5) + 8
Cache<String, Object> cache = Caffeine.newBuilder()
    .expireAfterWrite(randomNumber, TimeUnit.SECONDS) // 数据写入后 8 到 12 秒过期
    .build();
```

btw：之所以设置上一个 8 秒到 12 秒之间（中位数 10 秒）的过期时间，而不是直接设置为 10 秒的固定值，旨在防止应用服务器上的 POI 数据在一秒钟内集体过期，从而形成“缓存雪崩”的现象。



## Caffeine 的适用场景

其实写到这里，对于 Caffeine 本地缓存的适用场景，答案已经呼之欲出了。

我们来做下总结：

1. 受限于应用服务器内存的原因，Caffeine 需要缓存的数据量不宜过大，否则会频繁出现 Mixed GC 或 Full GC 的情况，也会导致系统在上线发布后需要缓存预热较长时间。

2. 系统 QPS 高且返回结果的数据量偏大，Redis 集中式缓存的网络容量会成为瓶颈的情况。

3. 被 Caffeine 所缓存的数据对时延性要求不高，可以接受数据变更在一段时间后（通常是秒级或分钟级）才能生效的情况。

以上**三个条件最好全部都满足**，才是 Caffeine 本地缓存的最佳适用场景。



## 总结

在本文中，我们先是表达了 Redis 集中式缓存适用于 90% 业务场景解决方案的观点，然后又从存在即合理的角度，举了一个使用 Caffeine 本地缓存的真实案例，最后帮大家总结梳理了 Caffeine 本地缓存的适用场景。

最后需要提醒的是：除非业务场景所迫，我们**尽量不要将 Redis 集中式缓存和 Caffeine 本地缓存结合在一起使用**，毕竟会引入新的缓存数据一致性的问题。