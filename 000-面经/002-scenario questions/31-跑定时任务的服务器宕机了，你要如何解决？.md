在技术面试过程中，候选人在回答面试官项目问题的时候，会不经意地说出这样的话：“我们系统中的 XXXX 功能是通过定时任务来实现的，具体的实现方式是......（此处省略 300 字）。”

听到这里，有的面试官会不失时机地问上一句：“如果跑定时任务的服务器宕机了，你要如何解决呢？”

被忽如其来地这么一问，有些候选人会下意识地这样回答：“那我们赶紧去重启服务器，然后再重新跑定时任务。”

面试官马上追问：“只有这些吗？能不能系统性地展开讲讲？”

后续人想了一会儿，说道：“抱歉，我目前就知道这些了。”

其实，上述回答肯定不是面试官心中的理想答案，远远不止这么简单。回答这个问题，我们需要从`兜底策略`、`幂等性`、`断点续跑`等多个角度出发。



## 兜底策略

跑定时任务的服务器宕机，一共分为两种情况，任务`运行时宕机`和`非运行时宕机`。

### 非运行时宕机

非运行时宕机的问题其实很容易解决，只要做到去单点化，以集群模式执行定时任务即可。

这样的话，我们无论是通过 SpringTask 单机定时任务 + Redission 分布式锁模式，还是 XXL-JOB 分布式任务调度平台的故障转移模式，都可以很好地解决该问题。

单机定时任务的实现方式是，到了定时任务的执行时间，集群中的每台服务器都会运行相同的代码逻辑，但由于获取分布式锁的这个步骤在各服务器间是互斥的，因此只有一台服务器可以获取成功，继续往下执行定时任务的业务逻辑。

换言之，哪怕集群中仅剩下一台服务器是可以正常工作的，那定时任务就可以正常运行。

如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aeb12037c01944a2bd6dcc1ea32879c8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=539&h=339&s=53900&e=png&b=fefefe" alt=""  /></p>


分布式任务调度平台的实现方式是，XXL-JOB 的调度中心会调用集群中的任意一台服务器（执行器），让其去执行定时任务的业务逻辑，当调度中心发现这台服务器没有响应时，就转而调用集群中的其他服务器去执行业务逻辑，这就是**故障转移模式**。

如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82ca328563164ee7b6afec397ef8377e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=642&h=361&s=33628&e=png&b=ffffff" alt=""  /></p>



同样的，哪怕集群中仅剩下一台服务器是可以正常工作的，那定时任务也可以正常运行。

也有的同学会说，单台定时任务服务器也没事，通过监控告警的方式通知到工程师，让他们重启服务器就好了，无非就是人工介入一下而已。

这样虽然也可以，但现实情况是，很多业务系统的定时任务，都是半夜一两点这种业务低峰期去执行的。那就真的有可能，就算告警了也叫不醒一个熟睡的人。



### 运行时宕机

相比较于非运行时宕机，运行时宕机的情况要复杂一些，因为它是区分业务场景的。

假设这样一种业务场景：我们希望通过凌晨两点执行的定时任务，将昨天在电商平台下过单的用户标记为 “活跃用户”。

这种情况下，哪怕定时任务在运行期间服务器宕机了，只要不是就集群内的所有服务器全部宕机，我们还是可以通过技术策略，避免人工介入。

方案很简单，我们可以在数据库中设置一个任务执行情况的标志位，根据标志位的状态决定是否重复执行即可。

如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b03efef45f94932b0932f8ea1a094d0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=405&s=102816&e=png&b=fefefe" alt=""  /></p>



不过，这个技术方案本身，是对业务场景或业务逻辑代码有一定要求的，我们继续往下看。

再假设这样一种业务场景：我们希望通过凌晨两点执行的定时任务，给昨天在电商平台下过单的用户增加相应的积分。

在这种业务场景下，就不适合上述“任务重复执行兜底”的解决方案了，因为简单粗暴地重复执行任务，会给已经增加过积分的用户再次增加积分，从而造成公司的经济损失。

这就要求我们，必须将执行定时任务的业务代码做到“幂等性”。


## 幂等性

在计算机领域中，幂等性（Idempotence）是指任意一个操作的多次重复执行，对系统所产生的结果则是相同的。

其实“保证幂等性”的解决方案非常简单，既然要保证“多次重复执行一个操作，结果是相同的”，那我们就通过某个唯一值进行幂等性校验就好了。

接下来我们看下，通过凌晨两点执行的定时任务，给昨天在电商平台下过单的用户增加相应的积分，这种场景下是如何进行幂等性校验的。

既然在正常情况下，该定时任务执行且仅执行一次，那就我们就可以在数据库中创建一个“积分明细表”，然后把“当天日期 + 分隔符 + 用户 ID”组合起来，作为该表中的字段之一，并为该字段创建一个唯一索引即可。

如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40581d67bca94a338f1702f2d53dde17~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=593&h=204&s=33512&e=png&b=d9deef" alt=""  /></p>



通过这种方式，即使是在定时任务重复执行的场景下，我们也彻底地杜绝了“在一天内，为同一个用户增加两次及以上积分”的情况。

目前，我们的定时任务已经具备了“兜底策略”和“幂等性”，是不是就任何业务场景都通吃了？其实还不是。

我们再假设一个业务场景：我们希望通过凌晨两点执行的定时任务，给电商平台的两亿用户全部添加相应的积分。

这种情况下，虽然我们的定时任务具备了“兜底策略”和“幂等性”，但如果在定时任务马上就执行完成的时候，服务器出现了宕机的情况，难道还要将这个大定时任务整个重跑吗？

要知道，给两亿用户发积分，是一个非常耗时的操作，就算每个小时能发送一千万个用户，也得 20 个小时才能完成。这也就意味着，需要延期整整一天，公司的业务部门是不能接受的。

这时，我们需要继续升级技术方案。


## 断点续跑

定时任务断点续跑，就是从上次任务中断的地方继续执行，而不是完全推倒重来一次，这样做可以有效地缩短任务运行时长。

如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/240cfa258b3248f2875cf6479805233f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=714&h=272&s=43990&e=png&b=ffffff" alt=""  /></p>



如果定时任务是以用户 ID 的升序执行的，那我们在程序中就可以先行判断，找出“积分明细表”中的最大用户 ID，然后将其 +1，继续执行即可。



## 总结

在本文中，我们结合于实际业务场景，从兜底策略、幂等性、断点续跑等多个角度出发，深入浅出地逐步带大家优化定时任务宕机后的解决方案。

同样，该解决方案是经过线上场景真实验证过的，完全经得起真实工作场景和回答面试官技术问题的推敲。