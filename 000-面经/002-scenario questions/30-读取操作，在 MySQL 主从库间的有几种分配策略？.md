在技术面试中，一旦在候选人的项目场景中聊到了数据库的相关内容，通常会有这样的几个高频问题：

- 说说在你的项目中，是如何进行 SQL 优化的，最终达成的效果怎样？
- 你项目中的分库分表方案是什么，以及是如何进行方案考量的？
- 你的项目中用到了从库，那说下读取操作是如何在主从库间进行分配的？

前两个问题已经在小册之前的文章中讲过了，本文我们就来讲一讲 “读取操作，在 MySQL 主从库间的有几种分配策略”，以及在真实的项目场景中，对这几种分配策略需要进行哪些方面的考量。



## 读取操作考量点

我们在做读取操作的分配策略的时候，需要考虑的有四种因素：`研发效率`、`主库压力`、`数据时延性`和`系统可用性`。另外，这四种因素是不可兼得的，需要根据真实业务场景去进行选择和取舍。

## 读取操作分配策略

### 1. 读写分离

众所周知，在 MySQL 数据库的主从模式下， 有且只有一台主库能够支持数据的读写操作（select、insert、update、delete、replace），而其他从库则仅能支持数据的读取操作（select）。

既然如此，也就意味着 MySQL 主库是相对稀缺的资源，如果我们让主库仅负责数据的写操作，而所有的数据读取操作都由其他从库来负责，这就是所谓的 “读写分离”。

这种读请求分配策略实现起来比较简单，并且让稀缺的资源只专注做一件事情，这从资源分配合理性上讲也是完全自洽的。

看起来一切都那么美好，但事实的真相往往比较残酷，这种策略并不是适用于任何场景的，因为其存在着一个比较大的弊端。

我们来看一下，MySQL 数据库主从复制的具体实现步骤，如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad9ad78181b74d4280ccfec9055ed065~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=405&s=68389&e=png&b=fefefe" alt=""  /></p>


（1）当 MySQL 数据库出现写操作（insert、update、delete、replace）时，主节点会将该变更记录到 Binlog 文件中，并通过 Log Dump 线程将 Binlog 发送到从节点。

（2）从节点的 IO 线程，接收到主节点的 Binlog Dump 线程发送过来的 Binlog 后，将其保存到本地的 Relay Log（中继日志）中。

（3）从节点的 SQL 线程读取 Relay Log（中继日志） 中的内容，将其解析成对应的 SQL 语句并执行，从而保证 MySQL 主从节点数据的最终一致性。

从主从复制的具体实现步骤中可以看到，其只能保证主库和从库数据的最终一致性。这也就意味着，主从库间的数据是存在一定时延性的。

假设如下场景：

（1）在一个接口中，当我们往数据库中写入一条数据后，紧跟着就通过 By ID 的方式， 把该条记录从数据库中读取出来。

（2）如果使用了 “读写分离” 策略的话，很有可能该条数据的 “主从复制” 还没有完成，在从库中读不到这条数据，从而导致了业务代码执行的错误。

因此，“读写分离” 策略的适用场景为，对数据时延性要求较低的业务场景，比如：前文中讲到的 “电销数据看板” 这种统计分析类场景。

如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/189413f72a3842d69b7dd4c86f1134d9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=417&s=200376&e=png&b=f6f5f5" alt=""  /></p>


“读写分离”策略中的读取操作一刀切全部走从库，不需要 case by case 地逐个 SQL 进行分析，因此其具备 “研发效率高，且主库压力低” 的特点。


### 2. 读写分离兜底版

还是这个场景：

（1）在一个接口中，当我们往数据库中写入一条数据后，紧跟着就通过 By ID 的方式，把该条记录从数据库中读取出来。

（2）如果使用了“读写分离”策略的话，很有可能该条数据的“主从复制”还没有完成，在从库中读不到这条数据。

（3）而在这时，我们通过二次读取的方式，在主库重新读取这条记录进行兜底，这样就可以避免出现“业务代码执行的错误”的情况。

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdcf314dc5c749ea920bc9a31bdd7ccc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=529&h=358&s=35811&e=png&b=ffffff" alt=""  /></p>



但是，需要注意的是，该策略只适用于主库“写入数据”的场景，并不适用于“更新数据”的场景。因为其无法判断从库中的数据，是否为“更新后的数据”。

“读写分离兜底版”策略，并不适用于写操作密集型的业务场景，因为二次读取操作的方式会增加主库的压力，并且其无法解决“更新数据”的主从库读取判定，使用场景相对受限。

此外，该策略中的读取操作，同样不需要 case by case 地逐个 SQL 进行分析，研发效率高。

### 3. 数据时延性分离

这种策略理解起来比较简单，我们需要对系统中的读取操作进行梳理，对数据时延性要求较低的读取操作走从库，要求较高的读取操作走主库。

如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/622464898b43492eb35014e093e3254b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=490&h=350&s=39928&e=png&b=fefefe" alt=""  /></p>



“数据时延性分离”策略，同样不适用于写操作密集型的业务场景，因为“对时延性要求较低的读取操作走主库”的方式会增加主库的压力，除此之外的场景都比较适合。

该策略完美地解决了数据时延性的问题，但需要 case by case 地逐个 SQL 进行分析，研发效率低。


### 4. 重要等级分离

我们在小册前文 “[提升可用性三部曲：缩小故障范围](https://juejin.cn/book/7331654939661795339/section/7332473679978987532)” 曾经说过，分布式系统中，各个微服务是按照其重要程度划分等级的，如：P0 级（非常重要）、P1 级（重要）、P2 级（一般）、P3 级（不重要）。

提到了微服务分级，那就不得不说另一个专业术语 —— 核心链路拆分。

核心链路拆分，识别并拆分出 P0 级别的服务，使其与非 P0 级服务在资源上（MySQL、Redis、MQ、ES 等）进行完全隔离，在服务间可具备可隔离性（熔断、降级、代码级容错处理），以保证系统核心功能的可用性。

另外，重要等级划分不仅仅作用在不同服务上，同一个服务部署多个集群，每个集群也可以有不同的重要等级。

举个例子，给用户端服务、商家端服务和订单中心提供接口的商品中心服务的集群，与给客服平台、CRM 和结算系统提供接口的商品中心服务的集群，它们的重要等级是不一样的。

前者 100% 是 P0 级服务，而后者也就是个 P1 级的服务。如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/812db88b613f4d36a7cfeb76204d161a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=401&s=26938&e=webp&b=fefdfd" alt=""  /></p>


既然服务等级划分出来了，那服务所对应的读取操作，也要做到“按重要等级进行分离”的策略。

也就是说，P0 级服务的读取操作走主库（或加上特定从库），而非 P0 级服务的读取操作则走其他从库，通过硬件资源彻底隔离的方式，保证系统核心功能的可用性。

由此可见，“重要等级分离”策略，则只适用于对系统可用性要求较高，需要做链路隔离的业务场景。



## 总结

在本文中，我们梳理了 MySQL 读取操作的 4 个考量点，然后又深入剖析了读取操作在主从库间的 4 种分配策略，以及其所对应的适用场景。

希望大家在技术面试中妥善应对面试官的同时，也可以按照这篇文章去落地工作中的真实业务场景。