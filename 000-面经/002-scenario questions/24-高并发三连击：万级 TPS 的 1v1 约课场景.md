在技术面试的时候，我们经常会谈到所谓的 “三高” 场景的解决方案，即：`高并发`、`高可用`和`高性能`。

但相对于高可用和高性能解决方案的清晰明确，高并发的解决方案则多少有些边界不清晰。

比如，“引入分布式缓存”和“进行数据库优化”是高性能的解决方案，但仔细一想，这两种方案可以帮助系统扛住更多并发请求，同样算是高并发的解决方案吧。

比如，“限流”和“熔断”是高可用的解决方案，其本质是抛弃请求，而不是处理请求，但它确实也能解决高并发的问题。

当然，这也是一个没有标准答案的问题，每个人心中都有属于自己的哈姆雷特。接下来，列举一下我认为的高并发解决方案。

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2aacb32fa2224c7d897361517a52a716~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=661&h=323&s=67588&e=png&b=ffffff" alt=""  /></p>



## 高并发解决方案

### 横向扩容

其实就是**堆机器**。应用服务器是瓶颈，那就堆应用服务器；数据库服务器是瓶颈的话，那就堆从库；其他中间件是瓶颈的话，那也堆起来。

不要觉得这种方案 Low，它至少可以解决 `50% 以上`的并发问题，且具备简单高效的特点。



### 引入缓存

这种方案比横向扩容的方案更加复杂一些，因为它会涉及到缓存选型和数据一致性的问题。当然，95% 的业务场景下，可以无脑选择 `Redis`。


### 引入 ES

高并发的多维复杂查询场景中，ES 通过其`分词器 + 倒排索引`的实现方式，相比较于 MySQL 的 B+ 树索引和 Key，Value 结构的 Redis，支持起来要好很多。

倒排索引结构如下：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae461bedebbf4860949ef47bafd6e04b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=349&s=101135&e=png&b=ffffff" alt=""  /></p>


上述三种方案，都是用于解决`“读多写少”`的高并发场景。

接下来，我们继续列举`“写多读少”`的高并发场景的解决方案。

### MQ 消峰

写请求来了不做任何操作或只做简单操作，然后往 MQ 里扔，由 MQ 的消费者按照节奏慢慢进行处理。

不过，有一点需要提醒，**MQ 更多的是解决系统中瞬时“写多读少”的高并发场景的问题**。如果请求量长期居高不下，而导致 MQ 消费者的消息越来越多地积压，此时需要做的是提升消费者的处理能力。


### 分库分表

分库分表可以分为垂直拆分和水平拆分，我们这里主要是指**水平拆分**。

- 通过水平分库，可以解决高并发写操作所带来的`硬件资源瓶颈问题`。
- 通过水平分表，可以解决高并发写操作所带来的`数据库锁瓶颈问题`。


### 单元化

阿里叫 Cell 化，美团叫 Set 化，其实说的都是一个东西。

所谓单元化，就是**将用户的请求流量，按照特定的规则路由到不同的“单元”内，且保证在“单元”内做到整个业务逻辑的闭环**，起到分散系统高并发压力，快速支持扩容和切换容灾的作用。

美团外卖，用的就是一个标准的单元化解决方案，使用的 Sharding Key 为 CityID。

综上所述，我们发现对于高并发写操作的底层解决思路，还是非常容易进行归纳总结的。即：

1.  瞬时流量洪峰通过消峰（MQ 消峰）的方式解决。
1.  持续的高并发流量，则通过分散热点（分库分表、单元化）的方式进行解决。当然，瞬时流量洪峰也可以通过分散热点（分库分表、单元化）的方式进行解决。

说了上面这些，接下来我们回归文章主题 —— “万级 TPS 的 1v1 约课场景” 的解决方案。



## 真实案例

### 业务场景 & 对应指标

某大型在线教育公司，其核心业务是 1v1 英语素质教育，当前注册学员的数量达到了百万量级。

该公司存在这样的一个业务场景，每周五中午 12 点开放预约下周的课程。那么，系统百万用户中的大部分人都去抢着预约心仪老师的课程。

如下图所示：


<p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4030b36fd0b2471c98178093589d55b1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=845&h=619&s=489615&e=png&b=ede6e3" alt="image.png"  /></p>



此时，约课系统需要承担的请求压力极大，尤其是最为核心的“预约课程”接口，每周五中午 12 点到 12 点 10 分期间的 TPS 甚至可以达到万级别。

因此，在我们进行系统改造优化之前，在 “每周五中午 12 点到 12 点 10 分” 这个时间段内，经常会出现系统扛不住请求流量而导致宕机的情况出现。



### 思考和落地路径

**Kafka MQ 模式**

我们套用一下文中所说的高并发写操作的底层解决思路 —— 瞬时流量洪峰的情况下，可以通过消峰（MQ 消峰）的方式解决。

如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b43a5e27205346d3b308adafddc79271~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=401&s=65608&e=png&b=fefefe" alt=""  /></p>


在 “约课前置服务” 中只做了很简单的事情，就是将用户的约课请求发送给 Kafka Broker，然后返回给用户“约课已提交，请在‘我的预约’中查看约课结果”的返回响应。


不过由于前十分钟的流量太大，因此我们还是调整了 Kafka 的生产者参数，如下：

-   batch.size = 32768（32KB）
-   max.in.flight.requests.per.connection = 100
-   buffer.memory = 67108864（64M）
-   acks = 0
-   compression.type = lz4

> 参数详解请见本小册的[第 12 章《Kafka 生产者吞吐量调优，那些参数和那些原理》](https://juejin.cn/book/7331654939661795339/section/7332670778309083155)

通过牺牲可靠性、时延性和 CPU 开销的方式，将 Kafka 的生产者吞吐量提升了 300% 多。

而在作为 Kafka 消费者的“约课服务”中，我们实现了全部业务逻辑，比如：生成约课记录、占用老师的 Time Slot、扣减课时、后调课标等。

另外，由于作为 Kafka 消费者的 “约课服务” 业务逻辑较重，因此在约课请求的瞬时流量洪峰下，其消费速率远远比不上作为 Kafka 生产者的 “约课前置服务” 的生产速率，会存在几分钟的 “约课结果” 的时延性。

而在这几分钟里，用户虽然收到了 “约课已提交，请在‘我的预约’中查看约课结果” 的返回响应，但却并不能在 “我的预约” 中查看到刚刚的约课记录，无论是约课成功还是约课失败，因为该条约课记录还在 Kafka 的 Broker 中排队等待处理。

这确实给用户带来了非常不好的体验，我们需要进行解决。

**`Kafka MQ + Redis List 模式`**

其实解决方案也很简单，虽然未进行分库分表的 MySQL 扛不住万级的约课 TPS，但 Redis Cluster 是可以抗住的。

我们把还在 Kafka Broker 中排队的约课记录，通过 Redis List 数据结构，以用户 ID 作为 Key、一或多个约课记录作为 Value 再存储一份。

存储格式如下：

```
List Key：userid:123456 Value：{预约课程1：2023年10月10日 8点30分, 预约课程2：2023年10月11日 9点} 

List Key：userid:234567 Value：{预约课程1：2023年10月12日 10点, 预约课程2：2023年10月13日 8点30分} 

```

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd83a1e380c1440688bbdc8fe69264d5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=413&s=72380&e=png&b=fefefe" alt=""  /></p>


详细方案如下：

1.  当作为 Kafka 生产者的 “前置约课服务”，将用户的约课请求发送给 Kafka Broker 时，也通过 Redis List 的 lpush 操作进行写入。


2.  当用户在 “我的预约” 里面查看约课记录时，把已经产生结果的约课数据从 MySQL 中读取出来，并未产生结果的约课数据从 Redis List 读取出来，两者进行聚合后再展示给用户。


3.  当作为 Kafka 消费者的 “约课服务”，将最早的一条约课记录进行业务处理并 MySQL 入库后，即可通过 Redis List 的 lrange + rpop 操作进行确定并移除。



## 总结

在本文中，我们先是给大家介绍了高并发场景的六大解决方案，然后再通过进化后的 MQ 消峰（`Kafka MQ + Redis List`）模式，抗住了万级 TPS 的 1v1 约课场景。

从这里我们也可以看出来，技术方案绝不是完全生搬硬套的，需要根据不同的业务场景进行灵活的适配。