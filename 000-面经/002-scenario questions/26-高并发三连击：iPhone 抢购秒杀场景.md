不得不说，秒杀场景如何应对，绝对是技术面试中最高频的场景面试题了，没有之一。

甚至有些财务领域、OA 领域公司的面试官也跟风问这个问题，大有一种 “无秒杀，不面试” 的感觉了。如果候选人的简历上恰好写了一个电商的项目，那这个问题被问到的概率会更大，甚至无限接近于 100%。

当然，秒杀场景的难易度也是分级的，参与秒杀的商品数量越少，那热点数据也就越集中，其处理难度也就越高。而像 iPhone 抢购秒杀场景这种单商品类秒杀，则无疑是秒杀中的战斗机。

当然，以现在的技术方案成熟度，解决这种秒杀场景比以前容易得多了。



## 技术难点拆解

秒杀场景其实就涉及到三个点：`商品展示`、`库存展示`和`下单支付`，接下来我们就一一进行解答。

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d40dd6a7fd024c219d3fa3041f5a28de~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=563&h=379&s=38667&e=png&b=ffffff" alt=""  /></p>


### 商品展示

商品信息的数据在秒杀过程中不会变更，基于此情况，其实从前端上就可以做解决方案。

方案如下：

正常情况下，商品详情页的数据都是后端服务接口返回的，但在特定的 iPhone 单品秒杀场景中，我们可以把整个商品详情页改造成静态页面，并放入到 CDN 服务器中。这样用户的查询请求就根本打不到服务器端来了，直接在前端进行处理了。

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b314fb7658e54449842dc4677758d9ec~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=1558&s=696689&e=png&b=f7f2ef" alt=""  width="50%"/></p>


当然，如果不想把解决方案做到前端，由后端进行处理解决也非常简单，我们可以用缓存预热的方式，将商品数据存入到本地缓存 Caffeine 上。

这里之所以选择 `Caffeine` 本地缓存，而不是 Redis 集中式缓存的原因在于：

1. 可以减少应用服务器去调用 Redis 服务器的网络 IO 操作，提升系统性能和吞吐量。
2. 避免该 Key 成为 Redis Cluster 中的大热 Key ，从而使网络带宽成为系统中的瓶颈点。

唯一的技术难点在于，需要对用户的每秒查询请求数（QPS）进行精准地预估，因为很多用户在秒杀场景中有不停刷页面的行为，所以我们需要将 QPS 预估得大一些。


### 库存展示

库存展示比商品展示在处理上要难上一些。因为在秒杀的过程中，库存是一个高频变化中的数据，我们不能简简单单地将库存数据吃进 Redis 中就完了。

但如果我们用标准的 “延时双删” 策略来处理缓存变更，那库存数据在 Redis 中的变更频率又太快了，似乎也没什么必要。

延时双删，主要是解决高并发读写下 MySQL 和 Redis 中数据不一致的问题。

我们还是用电商下单扣减库存进行举例。

1.  某商品的库存数为 10 个，用户 A 购买一件商品时进行库存扣减，因此第一步先删除 Redis 中的库存数。
1.  这时，用户 B 查询该商品的库存，发现 Redis 中并没有该商品的库存，于是从 MySQL 中读取库存数后，将其写入到 Redis 中（10 个）。
1.  然后，用户 A 更新数据库，将库存数从 10 个扣减为 9 个。
1.  最终，Redis 中的库存数是 10 个，而 MySQL 中的库存数是 9 个，出现了数据一致性的问题。

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9a400fc9f4642f5b1e2967da3447910~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=439&s=187304&e=png&b=fcfafa" alt=""  /></p>



而“延时双删”策略，则是在上述步骤中，又增加了最后一步 Redis 删除的操作。通过这种方式，可以最终解决 MySQL 和 Redis 中数据不一致的问题。

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6140f4569db0422c854fa825cd97656d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=412&s=176742&e=png&b=fbf9f9" alt=""  /></p>



> 有感兴趣的同学请见我的掘金文章《[面试官：如何保证 MySQL 和 Redis 中的数据一致性？](https://juejin.cn/post/7284630352789110824)》，在这里就不过多地进行展开了。

而我们实现的方案是，通过设置一秒过期时间的方式，使其到期后自动失效，然后通过用户请求再将其加载进缓存。通过这种方式，我们对于 Redis 中库存数的更新操作，降低至了每秒钟一次。

有的同学会有疑惑，通过这种方式进行实现，那页面上展示的库存数据是不准确的，数据会存在一秒钟的时延，这难道没事吗？

其实没事的。在高并发场景下，当库存数从数据库中读出来的那一刹那，甚至还没有渲染到网页上的时候，就已经存在时延性了。我们只需要保证库存扣减的时候准确即可。

同学的另外一个疑惑是：一秒钟过期的 Redis Key，存在的意义大吗？

我认为还是很有意义的，在高并发场景下，一秒钟过期的 Redis Key 可能就会被访问几千次甚至更多。


### 下单支付

在此之前，我们先来回顾一下前两个高并发场景：作品点赞场景和学生约课场景。

- 作品点赞场景，用户的所有请求基本上都产生了结果，也就是对自己喜欢的作品点赞成功了。
- 学生约课场景，用户的一部分请求产生了结果，约到了自己心仪老师的课程时间，或是退而求其次地约到了其他老师的课程时间。

因此，这两种业务场景非常适用于我们常规的高并发解决方案—— MQ 消峰和分库分表。

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cd58926a7144adf95939b794963e7b4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=661&h=323&s=71597&e=png&b=ffffff" alt=""  /></p>


而 iPhone 单品秒杀场景则完全不一样，用户的请求只有极少一部分会产生结果，也就是以便宜的价格买到 iPhone 手机，因为下单抢购的请求数要远远大于商品的库存数 N 个量级。

在这种情况下，其实根本没必要对用户的请求照单全收，我们首先要做的事情就是拒绝请求，也就是限流、流控，而不是自由下放这些请求去抢占库存。

举个例子：如果 iPhone 手机有 10 个库存要抢，那我们通过 Sentinel 把下单接口在集群中的整体 TPS（每秒处理的事务数量）限制在 20 即可，多放进去一些请求进去，可以保证库存能够全部被抢完。

当我们把这件事情做完后，所谓的 “高并发抢占库存” 的场景也就不存在了。如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bc24d1a34394bc3b67b1f4d60710818~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=494&h=409&s=32878&e=png&b=ffffff" alt=""  /></p>


所以，我们的库存扣减操作就只需要一条 SQL 语句即可，且单条 SQL 语句为原子性操作，也就完全不必担心会有库存超卖问题了。

如下所示：

```
update product set stock_number = stock_number - 1 where id = 12345 and stock_number > 0
```

上述的解决方案是针对于极少量库存的 iPhone 抢购秒杀场景，如果库存要多一些，比如 5000 个的话，那就不能用上述的限流解决方案了。

因为，我们总不能为了缓解库存扣减压力，通过 Sentinel 把下单接口在集群中的整体 TPS 设置为 1000，超过 1000 的请求全部流控拒绝了吧，毕竟此时库存数还是比较充裕的。

这时，我们的解决方案可以换成常规的通过 MQ 消峰的方式，把下单请求往 MQ 里扔，由 MQ 的消费者按照节奏慢慢进行处理扣减库存、创建订单和支付的整体业务操作。



## 总结

在本文中，我们对 iPhone 抢购秒杀场景的技术难点进行拆解，并逐一进行了技术方案的讲解，甚至在下单支付的环节，还按照秒杀商品的库存数量进行了方案拆分，也是希望能够在真实工作场景和技术面试中帮到大家。