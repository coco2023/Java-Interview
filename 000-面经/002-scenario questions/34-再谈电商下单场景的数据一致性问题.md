在技术面试中，如果面试官遇到候选人的简历中有电商领域的项目，大概率会抛出这样两个问题：“在你的系统中，如何解决订单和库存的数据一致性问题？又是如何避免的库存扣减超卖问题呢？”

这两个问题虽然是电商领域的高频问题，但能回答得自洽有逻辑性的候选人却不多，我们在本文中着重讲讲。

关于分布式系统的数据一致性问题，我们已经在上文中介绍了包括刚性和柔性在内的七大事务，接下来再来分析一下，电商下单扣减库存的业务场景适用于哪种事务。

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a0bd889a0654f39af4935f56ff34ba3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=668&h=390&s=38251&e=png&b=fffbfb" alt=""  /></p>



## 分布式事务选型

对于七大分布式事务的技术选型，仅仅知道电商下单扣减库存的业务场景是不够的，还需要从另外三个维度进行考虑，那就是：`请求并发度`、`库存充分度`和`整体链路长度`。

下面我们分别举出四种业务场景进行阐述。

### 业务场景 1

假设我们负责的是一个商品品类比较垂直的小众电商平台，日订单量几万单左右，业务链路只包括电商下单和扣减库存，属于请求并发度不高且整体业务链路偏短的情况。

我们在这种情况下直接无脑选择 2PC / 3PC 刚性事务即可，不但可以保证订单和库存数的强一致性，且代码开发成本极低，属于真正意义上的最优解。

### 业务场景 2

假设我们负责的是一个大型的旅游类电商平台，其中的酒店业务的日峰值订单量（五一、十一等节假日）可达到 500 万单左右，业务链路只包括电商下单和扣减库存，属于请求并发度高、商品库存并不充分、且整体业务链路偏短的情况。

我们在这种情况下，可以选择柔性事务中的 TCC（Try Confirm Cancel）模式，通过牺牲数据的强一致性和增加开发成本的方式，换取更高的请求并发度。

并且，其执行步骤中的先行资源预留隔离的方式，相比较于其他三种柔性事务（SAGA、本地消息表、MQ 事务消息），可以大大减少出现事务回滚操作的概率，提升系统的整体业务处理吞吐量。

### 业务场景 3

假设我们负责的是一个以小实物商品为主的大型电商平台，日订单量峰值可达到千万级别，业务链路只包括电商下单和扣减库存。

其最大的特点是，该电商平台上的商品库存充裕度非常高，“基本上”不会出现商品库存售空导致无法下单的情况。

我们在这种情况下，可以选择柔性事务中的本地消息表 / MQ 事务消息。

原因在于，通过消息队列的方式将部分业务流程异步化操作，可以很好地提升系统的业务处理吞吐量，且具备减少下单接口响应时间和降低系统服务解耦度的优点。

本地消息表 / MQ 事务消息虽然不具备 TCC 的资源隔离性，不过在商品库存充裕度高的情况下，资源隔离性并不属于强诉求，这种技术选型属于典型的扬长避短了。

### 业务场景 4

假设我们负责的是一个类似于马蜂窝的旅游 APP，该 APP 的“定制游”模块包含“三亚四天三夜游”类的旅游打包商品。

当用户购买该商品的时候，不仅仅在本方系统中下单和扣减商品库存，还需要调用航空公司系统的接口下单购买机票，神州租车系统的接口去进行租车，以及携程系统的接口去预订酒店房间和景区门票。

我们在这种情况下，选择且只能选择柔性事务中的 SAGA 模式，因为要求外部公司的系统共用全局强事务，提供 TCC 模式中的 Try 接口，或是以消息队列的方式进行通信，这些统统都是不现实的。

更何况，SAGA 模式本身就适用于这种长事务场景。



## 库存扣减超卖问题

其实，除了超大型电商平台的秒杀场景外，在我们真实业务场景中，库存扣减超卖基本上算是一个杞人忧天的问题。

每当听到几个工程师，在那如临大敌、孜孜不倦地讨论“日订单量大几万的电商平台的库存超卖问题”的解决方案时，我都会产生一种牛刀杀猪般的既视感。

库存超卖问题产生的原因是：多个用户线程同时读取某个商品库存数量，发现其库存数量是大于 0 的，随后同时进行商品下单和扣减库存操作，导致该商品的库存被扣为负数。

我们计算一下，一个日均百万订单的电商平台，只要不是存在非常明显的业务波峰波谷的情况，那每个小时基本上不会超过十万订单，然后再除以 3600 秒，得出来的结果是 —— 下单接口的 TPS 在 30 以内。

正常情况下，既然该电商平台都日均百万订单了，那售卖中的商品数量至少也得一万以上吧。如果下单接口 TPS 30 的话，别说库存超卖了，就连每秒钟同一个商品的库存被扣减两次的概率都比较低。

当然，如果想从根本上解决扣库存扣减超卖的问题，那其实更简单，直接一条 SQL 语句就搞定了。

```SQL
update 商品表 set 库存数量 = 库存数量 - 1 where 库存数量 > 0 and 商品ID = 1234
```

这条 SQL 语句具备了库存扣减和库存校验的双重职责，并同时具备原子性和隔离性的特点，所以永远都不会产生并发场景下的库存超卖问题。

有的同学会问，为什么不用分布式锁解决库存扣减超卖问题呢？

其实根本没有必要，明明一条 SQL 语句就可以解决的问题，非得先引入 Redission 的 JAR 包，再写上一大坨代码进行配置，最后还得在业务代码中进行加锁和解锁操作，何必这样小题大做呢？


## 总结

在本文中，我们聊了电商下单场景的两大高频问题：订单和库存的数据一致性和库存扣减超卖问题解决方案，旨在阐述三个观点：

（1）即使在相同的业务场景下，也要根据自己系统的特性做出最优解，不要直接拿来主义、生搬硬套解决方案。

（2）我们在进行架构设计、出技术方案的时候，一定要对系统中的业务数据有敏感度，根据系统的数据量级制定恰当的技术架构方案。

（3）技术解决方案不要复杂化、不要炫技，一定要做到“简单可依赖”，甚至 “恰好” 不需要解决它。

世界上解决一个计算机问题最简单的方法是 —— “恰好” 不需要解决它。很多所谓的“系统架构师”，一旦他们手里有了锤子，那真的是看什么都觉得像钉子。