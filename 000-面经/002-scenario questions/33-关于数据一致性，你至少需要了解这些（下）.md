在上一篇文章中，我们已经介绍了分布式事务中的刚性事务（2PC、3PC）。在本文中我们继续介绍柔性事务，其中包括补偿型的 TCC 和 SAGA，以及通知型的本地消息表、事务消息和最大努力通知，并对它们进行综合对比及剖析各自的适用场景。

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89317634dc8046549fcb8dfc45efb2db~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=668&h=390&s=37839&e=png&b=fffbfb" alt=""  /></p>


## 分布式事务

### TCC

TCC 是（Try Confirm Cancel）三个英文单词的缩写，共包括两个业务阶段，第一个阶段为 Try 阶段，第二个阶段为 Confirm / Cancel 阶段。

**1. Try 阶段**

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8685bfed116d4b39ba9ab14155f07a0d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=377&s=70076&e=png&b=ffffff" alt=""  /></p>


如上图描述，Try 阶段所做的事情是，对各个业务服务进行业务检查和资源预留，并返回结果。

**2. Confirm / Cancel 阶段**

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e413d890c7c4d0a9d3dd5844e9b7126~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=373&s=65335&e=png&b=ffffff" alt=""  /></p>


如上图描述：Confirm / Cancel 阶段则是根据 Try 阶段执行的结果，进行业务提交或业务回滚操作。

这里需要着重说的一点是，Try 阶段执行失败，可以通过 Cancel 阶段进行回滚兜底，但 Confirm / Cancel 阶段执行失败，则只能通过重试的方式进行补偿。因此， Confirm / Cancel 阶段所对应的接口代码实现，需要具备幂等性。

而一旦重试也失败了，则只能通过人工介入的方式进行最后的兜底操作。


**TCC VS 2PC**

细心的同学可能会发现，柔性事务 TCC 跟我们之前讲的刚性事务 2PC 是有相同点的，阶段一都是做一些前置化询问检查及业务预操作，阶段二再根据阶段一的返回结果，进行事务的正向提交或反向回滚/取消操作。

当前，其不同点也很明显：

-   2PC 基于数据库机制实现强一致性和隔离性，并发度低，但开发成本也低。
-   TCC 依靠业务代码实现最终一致性，通过业务资源冻结的方式实现隔离性，可以支持高并发场景，但是代码侵入性高，这意味着有较高的开发成本。


### Saga

Saga 是一种长事务（Long-running-transaction），由多个具有执行逻辑和补偿逻辑的本地事务组成，当其中的任何一个本地事务出错了，都可以通过补偿逻辑来进行恢复，从而达到事务的最终一致性。

其中，Saga 的恢复策略包括两种，向前恢复（Forward Recovery）和向后恢复（Backward Recovery）。

**1. 向前恢复**

如果长事务中的一个本地事务执行出错了，该策略会通过重试的方式继续向前执行，旨在最终将所有的子事务全部执行成功。

如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7128ba0738f248bfbebc9e2b5f5a27fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=703&h=187&s=27997&e=png&b=ffffff" alt=""  /></p>


**2. 向后恢复**

如果长事务中的一个本地事务执行出错了，该策略会以一种“一击不中，全身而退”的方式进行回滚，撤销掉之前执行成功的所有子事务。

如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c97cd7b04f24228bca5a8ff59410746~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=640&h=278&s=30775&e=png&b=ffffff" alt=""  /></p>



虽然 Saga 事务提供了向前恢复和向后恢复两种恢复策略，但仍然有可能出现事务执行失败，处于中间状态的情况。此时只能跟 TCC 事务一样，通过人工介入的方式进行最后的兜底操作。

Saga 有两种实现方式，一种是中心化的协调模式（Orchestrator），另一种是去中心化的编排模式（Choreographyo）。

**1. 编排模式（Orchestrator）**

Saga 编排器向各个业务服务发起命令，以此告知其需要执行本地事务还是回滚本地事务，这是一种中心化的实现方式。

如下图所示：


<p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21bd23b69b7f40298ec4d7379c9ca05f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=396&s=71794&e=png&b=fefefe" alt="image.png"  /></p>



**2. 协同模式（Choreographyo）**

编排模式基于中心化的 Saga 编排器实现，存在有单点风险，但在协同模式的实现方式中，每个业务服务都可以产生自己的事件，并监听其他业务服务的事件来决定是否执行/回滚本地事务，达到了去中心化的效果。

如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d294baca8cb442c68ef503bdeb699045~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=392&s=92426&e=png&b=fefefe" alt=""  /></p>


### 本地消息表

本地消息表是通过 MQ 进行实现的，其思想与 Saga 有类似的地方，也是将分布式事务拆分为本地事务进行处理，不同点在于其有事务主动方和事务被动方的概念。

如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c06b7d71695740229b9ca8dcb5ee92d3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=716&h=403&s=61802&e=png&b=fefefe" alt=""  /></p>



（1）事务主动方需要创建“本地消息表”，并将自身的业务操作和本地消息表的写入操作放在一个本地事务中，本地事务执行成功后往消息队列中发送消息。

（2）事务被动方接收到消息后，完成本地事务操作，并通知事务主动方已处理完成。

（3）事务主动方收到通知后，将本地消息表中对应记录的状态更新为“已处理”。


这里还有三点容错处理机制：

（1）如果事务被动方执行本地事务失败，则需要通知事务主动方“处理失败”，事务主动方进行回滚操作。

（2）如果本地消息表中的某条记录没有处于“处理完成”或“处理失败”的状态，则需要以定时任务轮询的方式进行重试，使其成为终态。

（3）如果本地消息表中的某条记录一直未处于终态，则需要通过人工介入的方式进行最后的兜底操作。


### MQ 事务消息

MQ 事务消息的整体流程和本地消息表很相似，唯一区别在于不需要在事务发起方维护那张消息表了，降低实现复杂度。

如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d8bd830cc394f1281b0096b0b7400b3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=402&s=70322&e=png&b=ffffff" alt=""  /></p>



当然，我们在自己的代码中做的事情少了，那也就意味着消息队列要做的事情就多了，我们看下 RocketMQ 4.x 版本的事务消息是如何实现的。

如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10a5bbe865f14a5191b23d7a505223dc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=350&s=93514&e=png&b=fefefe" alt=""  /></p>



上图中侧重于讲生产者与 RocketMQ 的交互情况，并未阐述如果在步骤 8 中，RocketMQ 往消费者投递消息失败了应该如何处理，我们在这里着重说明一下。

RocketMQ 源码的实现为，如果往消费者投递消息失败了，会进行 15 次重试。重试仍不成功的话，则需要通过人工介入的方式进行最后的兜底操作。



### 最大努力通知

最大努力通知的实现方式，算是“本地事务表”方案上的一个升级版本，在定时任务轮询上增加了执行力度和时间跨度，以体现其尽了“最大努力”。

还有一个特殊点是，在该事务模式下，并没有回滚操作，也就是说，事务被动方的处理结果不会对事务主动方的处理结果造成影响。

从这点上看，它并不属于严格意义上的事务。



如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22a25a1fba684cd8beb0f7a6fb16010e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=719&h=398&s=72471&e=png&b=fefefe" alt=""  /></p>



这里有两点需要注意：

（1）随着消息重发次数的增多，其重发间隔也要逐渐拉长，如：一分钟、三分钟、十分钟、一个小时、十个小时等，在提升消息通知成功率和减低系统硬件资源消耗上取得平衡。

（2）重发仍不成功的话，则需要通过人工介入的方式进行最后的兜底操作。

至此，我们终于将各个分布式事务全部讲完了，接下来从存在即合理的角度，介绍一下它们各自的适用场景。

## 综合对比

|                | 一致性 | 开发成本 | 并发度 | 隔离性 |
| -------------- | --- | ---- | --- | --- |
| 2PC / 3PC      | 高   | 低    | 低   | 有   |
| Saga           | 中   | 中    | 中   | 无   |
| TCC            | 中   | 高    | 中   | 有   |
| 本地消息表 / MQ事务消息 | 中   | 中    | 高   | 无   |
| 最大努力通知         | 低   | 中    | 高   | 无   |

## 适用场景

**2PC / 3PC**：要求系统数据的强一致性，比如：分库分表场景下的转账功能，数据库 1 中的用户 A 账户扣减 100 元，数据库 2 中的用户 B 账户增加 100 元。

**Saga**：适用于业务流程较长的业务场景，比如：旅游出行场景下的一键预定机票、酒店、景区门票及租车功能。

**TCC**：对资源隔离性和并发量要求较高的业务场景，比如：春运时期的 12306 抢票场景。

**本地消息表 / MQ 事务消息**：对接口响应时间敏感，存在系统间解耦诉求的业务场景，比如：订单支付成功通知物流系统。

**最大努力通知**：对数据一致性等级要求较低，且被动方的处理结果不会对主动方的处理结果造成影响，比如：合同签订成功的后续跟进处理流程，leads（潜在用户）获取后的分配流程。

## 总结

终于把分布式定理、分布式事务，以及其适用场景和综合对比讲完了，大家可以结合本文的知识，对自己的系统进行合理的技术选型，并以此应对面试官的技术问题。

btw：目前微服务架构是非常主流的架构方案，只要涉及到跨服务写操作，很容易引申到“分布式事务”这个技术点来，属于妥妥的高频面试题，大家一定要好好准备。