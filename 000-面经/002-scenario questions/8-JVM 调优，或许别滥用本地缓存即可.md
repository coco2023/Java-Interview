在真实场景中，其实 JVM 调优远不如代码优化或 SQL 优化那么有效果，但在面试中却经常会被问到。究其原因，我认为是出于人才筛选的考虑要大一些。

在技术面试中，面试官往往会由浅及深、逐层递进地问如下问题：

1.  在你的项目中做过 JVM 调优吗？
1.  JVM 调优的效果如何？
1.  可以讲一下具体的调优步骤吗？

我们先来回答第一个问题，是否做过 JVM 调优。

我的观点是，如果你回答“没做过，因为在项目中，没有遇到过需要 JVM 调优的场景”，有可能会被减分。原因在于，会被面试官认为“JVM 方向的知识比较匮乏”，或是“不具备做 JVM 调优的能力”。

因此，第一个问题我们只能回答“做过 JVM 调优”。






## JVM 调优效果

JVM 调优目标是需要进行二选一的，即：`最短停顿时间`或`最大吞吐量`，具体要达成哪个，需要根据我们的系统情况来进行判断。

-   **最短停顿时间**：JVM 的 GC 会 STW（Stop The World），这时将暂停所有应用线程，对于用户而言就有卡顿感了。因此，对于注重用户操作体验的系统来说，**缩短 STW 的停顿时间是系统调优目标**。

-   **最大吞吐量**：对于一些执行任务计算类的后台系统来说，其关注点并不是停顿时间，而是在单位时间内进行更多的任务计算，那么**获取最大的吞吐量则是系统调优目标**。


我们都听说过分布式系统的 CAP 定理：在一个分布式系统中，最多只能在一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）中三者满足其二，不能同时满足这三项。


JVM 调优也与其类似，**`最低内存占用率`**、**`最短停顿时间`** 和 **`最大吞吐量`，这三者也只能满足其二**，不存在三者兼得的情况。如果选择了其中的任意两个，必然会以牺牲另一个为代价。

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a96f12c000745ff9e21abd7b76f0264~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=386&h=270&s=19693&e=png&b=ffffff" alt=""  /></p>

再换句话说，在内存占用率恒定的情况下，最短停顿时间和最大吞吐量，我们系统的优化目标只能两者取其一。


基于 JVM 调优目标的讲述、对于面试官问第二个问题——JVM 调优效果，我们的回答方式为：

（1）经过本次的 JVM 调优，将系统中的 Full GC 时长从 4 秒钟降低至 0.5 秒。

（2）经过本次的 JVM 调优，系统中的 Full GC 次数明显减少，从 15 分钟一次减少至 5 个小时一次。

（3）经过本次的 JVM 调优，将系统吞吐量提升至 99%，GC 时长压缩至 1%。



## JVM 调优步骤

接下来，我们讲一下面试官的第三个问题——调优步骤。

### 1. 明确调优目标

两个方向性目标，最短停顿时间和最大吞吐量，这个上文已经说了，这里就不再赘述了。

### 2. 分析运行情况

在这一步，我们可以借助于主流的监控工具 Prometheus + Grafana ，再结合 JDK 自带的命令行工具（jps、jstat、jinfo、jstack 等）进行分析。

主要的分析点包括：Young & Full & Mixed GC 频率、Young & Full & Mixed GC 耗时、系统负载、CPU 使用率、JVM 参数配置，以及是否存在内存泄露、OOM、线程死锁等。



### 3. 参数配置调整

本着少即是多的原则，常见 JVM 调优参数如下：

```
//内存设置
//设置最大堆内存，该值设置过小会导致频繁Full GC或OOM，设置过大则会导致非堆内存消耗殆尽
//建议将该值设置为物理内存的60%——80%
-Xmx3072m

//初始堆内存，建议与-Xmx设置相同，避免每次垃圾回收完成后，JVM重新分配内存
-Xms3072m

//设置堆外内存，若不进行指定，则跟-Xmx值一致
-XX:MaxDirectMemorySize=512m


//设置垃圾回收器
//老年代使用Parallel Old收集器，新生代使用Parallel Scavenge收集器，以最大吞吐量为目标
-XX:+UseParallelOldGC

//使用G1收集器，会在吞吐量和停顿时间中进行平衡
-XX:+UseG1GC

//使用ZGC收集器，以最短停顿时间为目标
-XX:+UseZGC

//新生代使用Serial收集器，老年代使用Serial Old收集器。特点是占用内存小，启动速度快
-XX:+UseSerialGC

//其他类型参数
//对象从年轻代进入老年代的年龄值，JDK8默认值15，JDK9则将该值调整为7
-XX:InitialTenuringThreshold=7

//新生代可容纳的最大对象，超出该阈值则直接将对象分配到老年代，默认值为0，任何对象都先在新生代分配内存，
//不过，该参数只对Serial和ParNew收集器有效
-XX:PretenureSizeThreshold=1048576

//GC停顿时间，垃圾收集器会尝试用各种手段达到这个时间，但不能完全保证达成，该参数值不可设置过低，单位为毫秒
 -XX:MaxGCPauseMillis=200
 
 //设置GC的并行线程数量
 -XX:ParallelGCThreads=8

//Region中的存活对象低于这个值时，才会对该Region进行回收，否则存活对象占比较高，那回收的的意义
//就不大了，且复制的时间也会变长，默认85%
-XX:G1MixedGCLiveThresholdPercent=85

//Mixed GC是基于复制算法进行的，会把要回收的Region中的存活对象复制到其他Region中，然后再把这
//个Region清空，这样就会不断有新的Region空出来，一旦空出来的Region数量达到了堆内存的该参数比
//例值，就会立即停止混合回收，默认5%
-XX:G1HeapWastePercent=5 

//设置每个Region的大小，单位MB，需要为1，2，4，8，16，32其一，默认是堆内存的1/2000
-XX:G1HeapRegionSize=2
```

我们需要根据上述参数，以及系统的调优目标和当前实际情况，有针对性地进行参数调优。





### 4. 灰度差异对比

在我们进行 JVM 参数调优之后，不会直接应用到集群中的所有应用服务器中。

我们会先选择集群中的一台服务器，进行 JVM 参数优化后的灰度测试，将此台服务器的运行情况和集群中的其他服务器进行运行指标对比，以此得知本次 JVM 参数优化的效果。

除此之外，我们还需要观察这台灰度的应用服务器，是否有其他异常情况发生，影响了应用程序的正常运行。




### 5. 全量推进应用

如果经过观察对比，此台服务器的优化效果明显，且运行几天并无异常情况发生，我们将本次 JVM 参数优化的结果，全量应用在集群的所有应用服务器中。


至此，我们才算完成了 JVM 调优的整体闭环步骤。

接下来，我们举一个真实场景的例子，来帮助大家理解整体的调优步骤，以便更好地准备该问题的答案。



## JVM 调优真实案例



### 1. 案例背景

某在线教育公司有一个课程服务，该服务为公司所有上游服务（如：上课服务、作业服务、评价服务、约课服务、后台管理服务等）提供课程信息。


信息包括但不限于如下内容：课程学科、课程类型、课程目标、课程时长、授课老师、老师介绍、课程价格范围、课程日期、适合学员、课程简介、课程大纲。


如下图所示：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27c571bb056344d6871e2ed6713933e9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=669&h=300&s=33876&e=png&b=ffffff" alt=""  /></p>

  


### 2. 案例现象

有一天听学生端的同学反馈，他们的上课服务经常发生卡顿的情况，经排查是由于调用了下游的课程服务，导致课程服务的接口会在某个时间点存在部分超时的情况。

课程服务的同学听到反馈后，起初没太当回事，认为是网络抖动导致。但没过两天，教师端的同学也反馈了类似的问题。

于是，课程服务的同事通过 Prometheus + Grafana 监控系统 + JDK 自带的命令行工具进行排查，发现 JVM 的 Full GC 非常频繁，基本上十多分钟就会发生一次，每次的 GC 时间有十几秒。


### 3. 案例排查

课程服务的同事通过 JDK 中的 `jinfo` 命令进行查看，JVM 的核心参数配置如下：

```
-Xmx6144m
-Xms6144m
-XX:+UseParallelOldGC
-XX:InitialTenuringThreshold=7
```


通过 `jmap -histo` 命令进行排查，问题出在课程服务的高频核心接口——`getCourseInfo`返回的大对象上。其作用是，根据上游服务传入的查询条件，返回所有的课程信息。

该接口的查询条件有很多，比如：课程学科、课程类型、课程目标、课程时长、授课老师、课程价格范围、课程日期、适合学员等，QPS 1500+。

有一次，课程服务的 A 同学担心数据库压力过大，于是结合于课程变更频率很低、且变更可以接受时延的特点，从数据库读取后增加到了 Caffeine 缓存中，其中 key 为查询条件， value 为对应的课程对象，并将 maximumSize 参数设置为 100000，即：最多存储 10 万个。

A 同学没有想到的是，`getCourseInfo` 接口虽然查询出来的课程数量不多，但结果集中包括“课程简介”、“课程大纲”、“主讲老师介绍”类的大字段，占用空间不小，平均 50k 左右，有一部分能达到 150k+。

由于其各种条件项的排列组合，导致需要缓存的键值对很多，但命中率不高。且由于设置了 Caffeine 的 maximumSize 属性的原因，这些对象全部进入了老年代。


该接口被上游多个服务调用，属于高频访问接口，峰值 QPS 达到了 1500+，该服务的集群是 3 台 4c8g 的服务器，那么单台服务器的 QPS 是 500+，该对象每秒钟进入到老年代的大小达到了 10M+（部分查询命中缓存），这就是其频繁 Full GC 的原因。


### 4. 案例解决

定位到问题后，接下来就比较容易解决了。

（1）换一个以最短停顿时间为目标的垃圾收集器，来替代 Parallel Old 收集器，解决系统的长时间卡顿问题。

由于该系统用的是 JDK 1.8 版本，无法使用 ZGC 收集器，我们将垃圾收集器换成了 G1（XX:+UseG1GC）。

G1 收集器是一种基于 Region 的内存布局形式，进行局部收集的设计思路，其不仅仅停顿时间可控（默认 MaxGCPauseMillis 为 200ms），而且对系统吞吐量也很友好。

G1 堆内存布局如下：

<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdc773e94aeb45ce84a3a013eea0a9ae~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=600&h=200&s=20546&e=png&b=ffffff" alt=""  /></p>


（2）将代码中 Caffeine 缓存的 maximumSize 参数设置为 10000（之前是 10 万），减少 JVM 中长时间驻留对象的数量，解决潜在的 Mixed GC 频繁的问题。

经此调整后，系统在 Mixed GC 期间的停顿时间，从十几秒减少到了 200 毫秒左右，且相比于之前 ParallelOld 十多分钟一次的 Full GC 频率，调整后的 G1 Mixed GC 频率降低到了三个小时一次。


## 总结

本章我们从面试官的问题入手，讲述了 JVM 的调优目标、调优效果，以及调优步骤的方法论，先让大家对 JVM 调优的理论知识进行了储备。

接着我们又分享了一个真实的 JVM 调优案例，从最初的发现问题、定位问题到解决问题，进行了细致的步骤拆解，以理论结合实践的方式加深大家对于 JVM 知识领域的理解，并可以有逻辑性地跟面试官进行阐述回答。
