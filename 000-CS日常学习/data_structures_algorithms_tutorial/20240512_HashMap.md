refer: https://www.baeldung.com/java-hashmap-advanced#collection-views-in-hashmap

Keep in mind that itâ€™s the hash value of the key that determines the bucket the object will be stored in. And so, if the hash codes of any two keys collide, their entries will still be stored in the same bucket.

And by default, the implementation uses a linked list as the bucket implementation.

Overriding the `hashCode` and `equals` methods is crucial when creating custom objects that you intend to use as keys in a `HashMap`. These methods ensure that keys are correctly compared for equality and that they hash to the same bucket if they are considered equal.

Here's an example where we implement a simple `HashMap` that uses a custom key object. We'll override the `hashCode` and `equals` methods for the custom key class to ensure it works correctly as a key in our `HashMap`:

```java
import java.util.Objects;

class SimpleHashMap<K, V> {
    private Entry<K, V>[] buckets;
    private static final int INITIAL_CAPACITY = 16;

    public SimpleHashMap() {
        this.buckets = new Entry[INITIAL_CAPACITY];
    }

    private int getBucketIndex(K key) {
        return Math.abs(key.hashCode() % INITIAL_CAPACITY);
    }

    public void put(K key, V value) {
        int bucketIndex = getBucketIndex(key);
        Entry<K, V> newEntry = new Entry<>(key, value, null);

        if (buckets[bucketIndex] == null) {
            buckets[bucketIndex] = newEntry;
        } else {
            Entry<K, V> current = buckets[bucketIndex];
            while (current.next != null) {
                if (current.key.equals(key)) {
                    current.value = value;
                    return;
                }
                current = current.next;
            }
            if (current.key.equals(key)) {
                current.value = value;
            } else {
                current.next = newEntry;
            }
        }
    }

    public V get(K key) {
        int bucketIndex = getBucketIndex(key);
        Entry<K, V> current = buckets[bucketIndex];

        while (current != null) {
            if (current.key.equals(key)) {
                return current.value;
            }
            current = current.next;
        }
        return null; // Not found
    }

    static class Entry<K, V> {
        K key;
        V value;
        Entry<K, V> next;

        public Entry(K key, V value, Entry<K, V> next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    // Custom Key class with overridden hashCode and equals
    static class CustomKey {
        int id;
        String name;

        CustomKey(int id, String name) {
            this.id = id;
            this.name = name;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            CustomKey customKey = (CustomKey) o;
            return id == customKey.id && Objects.equals(name, customKey.name);
        }

        @Override
        public int hashCode() {
            return Objects.hash(id, name);
        }

        @Override
        public String toString() {
            return "CustomKey{" +
                    "id=" + id +
                    ", name='" + name + '\'' +
                    '}';
        }
    }

    public static void main(String[] args) {
        SimpleHashMap<CustomKey, String> map = new SimpleHashMap<>();
        CustomKey key1 = new CustomKey(1, "KeyOne");
        CustomKey key2 = new CustomKey(2, "KeyTwo");

        map.put(key1, "ValueOne");
        map.put(key2, "ValueTwo");

        System.out.println("Value associated with key1: " + map.get(key1)); // Outputs: ValueOne
        System.out.println("Value associated with key2: " + map.get(key2)); // Outputs: ValueTwo
    }
}
```

In this implementation:

- We have a `CustomKey` class with an `id` and a `name`, both used in the `equals` and `hashCode` methods to uniquely identify a key.
- The `equals` method ensures that two `CustomKey` instances are considered equal if both their `id` and `name` fields are equal.
- The `hashCode` method uses `Objects.hash` to generate a hash code based on the `id` and `name` fields. This ensures that equal keys will have the same hash code, which is essential for the correct functioning of a `HashMap`.
- In the `SimpleHashMap` class, the `getBucketIndex` method uses `Math.abs` on the hash code to avoid negative indices.

This setup allows the `SimpleHashMap` to use `CustomKey` instances as keys, with correct handling of key equality and hash codes.

## Overriding the `hashCode()` and `equals()` methods
Overriding the `hashCode()` and `equals()` methods in Java is crucial when creating custom objects that you intend to store in collections like `HashMap`, `HashSet`, or `Hashtable`, which rely on these methods to correctly identify and handle objects. Here's why:

### `hashCode()` Method:

- **Purpose**: The `hashCode()` method returns an integer value, generated by a hashing algorithm, which represents the instance of the class.
- **Usage in Collections**: Collections like `HashMap` use the `hashCode()` value to determine where to store the object internally. If two objects are equal according to the `equals()` method, they must return the same hash code. This is crucial for the retrieval process because the collection will use the hash code to look up the object.
- **Default Behavior**: The default `hashCode()` method in `Object` class typically converts the internal address of the object into an integer, which means two distinct objects will usually have two distinct hash codes.

### `equals()` Method:

- **Purpose**: The `equals()` method checks if some other object passed to it as an argument is equal to the object on which this method is invoked.
- **Usage in Collections**: It's used to compare two objects for equality. In collections, `equals()` is used to check if an entry already exists and to replace, retrieve, or remove it.
- **Default Behavior**: The default `equals()` method in the `Object` class checks for reference equality, meaning two references are equal only if they point to the exact same object.

### Consequences of Not Overriding:

1. **Incorrect Element Uniqueness**: If you use a custom object as a key in a `HashSet` or `HashMap` and do not override these methods, the collection might treat two logically identical objects as different, leading to duplicate keys/values where there shouldn't be any.

2. **Inconsistent Behavior**: If you override `equals()` but not `hashCode()`, two objects that are considered equal (same content) could have different hash codes, violating the contract of the `hashCode()` method. This will lead to inconsistent and incorrect behavior when your objects are used in hash-based collections.

3. **Inefficient Lookups**: Even if your custom object is used only as a value in a `HashMap` and not as a key, not overriding `hashCode()` and `equals()` could result in inefficient lookups and the inability to retrieve your objects even when they're present in the collection.

4. **Logical Equality Ignored**: Without overriding `equals()`, your objects will be compared for equality based on their memory addresses (reference equality) rather than their logical state (logical equality), which is often what you want.

### Best Practices:

- Always override both `hashCode()` and `equals()` for objects used as keys in collections to ensure consistent and predictable behavior.
- Ensure that if two objects are considered equal by the `equals()` method, they must also have the same hash code.
- Use tools like `Objects.hash()` (for `hashCode()`) and `Objects.equals()` (for `equals()`) from Java 7 onwards to simplify the implementation and reduce the risk of errors.