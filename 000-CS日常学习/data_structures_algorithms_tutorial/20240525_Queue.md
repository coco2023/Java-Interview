
### 239. 滑动窗口最大值 (Sliding Window Maximum)

This problem requires finding the maximum value in each sliding window of size `k` in an array.

#### Solution:
```java
import java.util.Deque;
import java.util.LinkedList;

public class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || k <= 0) {
            return new int[0];
        }
        int n = nums.length;
        int[] result = new int[n - k + 1];
        int ri = 0;

        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < nums.length; i++) {
            // Remove indices that are out of the current window
            while (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            // Remove elements that are smaller than the current element
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            // Add current element at the end of the deque
            deque.offer(i);
            // The first element in the deque is the largest element for the current window
            if (i >= k - 1) {
                result[ri++] = nums[deque.peek()];
            }
        }
        return result;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] nums = {1,3,-1,-3,5,3,6,7};
        int k = 3;
        int[] result = solution.maxSlidingWindow(nums, k);
        for (int num : result) {
            System.out.print(num + " ");  // Output: 3 3 5 5 6 7
        }
    }
}
```

### 232. 用栈实现队列 (Implement Queue using Stacks)

This problem requires implementing a queue using two stacks.

#### Solution:
```java
import java.util.Stack;

class MyQueue {
    private Stack<Integer> stack1;
    private Stack<Integer> stack2;

    /** Initialize your data structure here. */
    public MyQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }

    /** Push element x to the back of queue. */
    public void push(int x) {
        stack1.push(x);
    }

    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }

    /** Get the front element. */
    public int peek() {
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.peek();
    }

    /** Returns whether the queue is empty. */
    public boolean empty() {
        return stack1.isEmpty() && stack2.isEmpty();
    }

    public static void main(String[] args) {
        MyQueue myQueue = new MyQueue();
        myQueue.push(1);
        myQueue.push(2);
        System.out.println(myQueue.peek()); // returns 1
        System.out.println(myQueue.pop());  // returns 1
        System.out.println(myQueue.empty()); // returns false
    }
}
```

### 387. 字符串中的第一个唯一字符 (First Unique Character in a String)

This problem requires finding the first unique character in a string and returning its index.

#### Solution:
```java
import java.util.HashMap;
import java.util.Map;

public class Solution {
    public int firstUniqChar(String s) {
        Map<Character, Integer> countMap = new HashMap<>();
        Map<Character, Integer> countMap = new HashMap<>();        
        for (char c : s.toCharArray()) {
            countMap.put(c, countMap.getOrDefault(c, 0) + 1);
        }
        for (int i = 0; i < s.length(); i++) {
            if (countMap.get(s.charAt(i)) == 1) {
                return i;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        String s = "loveleetcode";
        System.out.println(solution.firstUniqChar(s)); // returns 2
    }
}
```

### 225. 用队列实现栈 (Implement Stack using Queues)

This problem requires implementing a stack using two queues.

#### Solution:
```java
import java.util.LinkedList;
import java.util.Queue;

class MyStack {
    private Queue<Integer> queue1;
    private Queue<Integer> queue2;

    /** Initialize your data structure here. */
    public MyStack() {
        queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }

    /** Push element x onto stack. */
    public void push(int x) {
        queue1.add(x);
        while (!queue2.isEmpty()) {
            queue1.add(queue2.poll());
        }
        Queue<Integer> temp = queue1;
        queue1 = queue2;
        queue2 = temp;
    }

    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        return queue2.poll();
    }

    /** Get the top element. */
    public int top() {
        return queue2.peek();
    }

    /** Returns whether the stack is empty. */
    public boolean empty() {
        return queue2.isEmpty();
    }

    public static void main(String[] args) {
        MyStack myStack = new MyStack();
        myStack.push(1);
        myStack.push(2);
        System.out.println(myStack.top());  // returns 2
        System.out.println(myStack.pop());  // returns 2
        System.out.println(myStack.empty()); // returns false
    }
}
```

### 1696. 跳跃游戏 VI (Jump Game VI)

This problem requires finding the maximum score you can get by jumping from the start to the end of the array, given you can jump at most `k` steps forward.

#### Solution:
```java
import java.util.Deque;
import java.util.LinkedList;

public class Solution {
    public int maxResult(int[] nums, int k) {
        int n = nums.length;
        Deque<Integer> deque = new LinkedList<>();
        deque.offer(0);
        for (int i = 1; i < n; i++) {
            nums[i] += nums[deque.peek()];
            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
                deque.pollLast();
            }
            deque.offer(i);
            if (i - deque.peek() >= k) {
                deque.poll();
            }
        }
        return nums[n - 1];
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] nums = {1, -1, -2, 4, -7, 3};
        int k = 2;
        System.out.println(solution.maxResult(nums, k)); // returns 7
    }
}
```

### 862. 和至少为 K 的最短子数组 (Shortest Subarray with Sum at Least K)

This problem requires finding the length of the shortest subarray with a sum of at least `K`.

#### Solution:
```java
import java.util.Deque;
import java.util.LinkedList;

public class Solution {
    public int shortestSubarray(int[] A, int K) {
        int n = A.length;
        long[] prefixSum = new long[n + 1];
        for (int i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + A[i];
        }

        int result = n + 1;
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i <= n; i++) {
            while (!deque.isEmpty() && prefixSum[i] - prefixSum[deque.peekFirst()] >= K) {
                result = Math.min(result, i - deque.pollFirst());
            }
            while (!deque.isEmpty() && prefixSum[i] <= prefixSum[deque.peekLast()]) {
                deque.pollLast();
            }
            deque.offerLast(i);
        }

        return result <= n ? result : -1;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] A = {2, -1, 2};
        int K = 3;
        System.out.println(solution.shortestSubarray(A, K)); // Output should be 3
    }
}
```

### LCR 125. 图书整理 II (Book Shelving II)

Since there isn't a direct LeetCode problem 125 related to book shelving, I'll assume this is related to arranging books or similar objects in a specific manner. If this is a custom problem, please provide more details or clarify the requirements.

### 641. 设计循环双端队列 (Design Circular Deque)

This problem requires designing a circular deque.

#### Solution:
```java
class MyCircularDeque {
    private int[] data;
    private int front;
    private int rear;
    private int size;
    private int capacity;

    /** Initialize your data structure here. Set the size of the deque to be k. */
    public MyCircularDeque(int k) {
        capacity = k;
        data = new int[capacity];
        front = 0;
        rear = 0;
        size = 0;
    }

    /** Adds an item at the front of Deque. Return true if the operation is successful. */
    public boolean insertFront(int value) {
        if (isFull()) {
            return false;
        }
        front = (front - 1 + capacity) % capacity;
        data[front] = value;
        size++;
        return true;
    }

    /** Adds an item at the rear of Deque. Return true if the operation is successful. */
    public boolean insertLast(int value) {
        if (isFull()) {
            return false;
        }
        data[rear] = value;
        rear = (rear + 1) % capacity;
        size++;
        return true;
    }

    /** Deletes an item from the front of Deque. Return true if the operation is successful. */
    public boolean deleteFront() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        size--;
        return true;
    }

    /** Deletes an item from the rear of Deque. Return true if the operation is successful. */
    public boolean deleteLast() {
        if (isEmpty()) {
            return false;
        }
        rear = (rear - 1 + capacity) % capacity;
        size--;
        return true;
    }

    /** Get the front item from the deque. */
    public int getFront() {
        if (isEmpty()) {
            return -1;
        }
        return data[front];
    }

    /** Get the last item from the deque. */
    public int getRear() {
        if (isEmpty()) {
            return -1;
        }
        return data[(rear - 1 + capacity) % capacity];
    }

    /** Checks whether the circular deque is empty or not. */
    public boolean isEmpty() {
        return size == 0;
    }

    /** Checks whether the circular deque is full or not. */
    public boolean isFull() {
        return size == capacity;
    }

    public static void main(String[] args) {
        MyCircularDeque circularDeque = new MyCircularDeque(3); // Set the size to be 3
        System.out.println(circularDeque.insertLast(1));  // return true
        System.out.println(circularDeque.insertLast(2));  // return true
        System.out.println(circularDeque.insertFront(3)); // return true
        System.out.println(circularDeque.insertFront(4)); // return false, the queue is full
        System.out.println(circularDeque.getRear());      // return 2
        System.out.println(circularDeque.isFull());       // return true
        System.out.println(circularDeque.deleteLast());   // return true
        System.out.println(circularDeque.insertFront(4)); // return true
        System.out.println(circularDeque.getFront());     // return 4
    }
}
```

### 622. 设计循环队列 (Design Circular Queue)

This problem requires designing a circular queue.

#### Solution:
```java
class MyCircularQueue {
    private int[] data;
    private int front;
    private int rear;
    private int size;
    private int capacity;

    /** Initialize your data structure here. Set the size of the queue to be k. */
    public MyCircularQueue(int k) {
        capacity = k;
        data = new int[capacity];
        front = 0;
        rear = 0;
        size = 0;
    }

    /** Insert an element into the circular queue. Return true if the operation is successful. */
    public boolean enQueue(int value) {
        if (isFull()) {
            return false;
        }
        data[rear] = value;
        rear = (rear + 1) % capacity;
        size++;
        return true;
    }

    /** Delete an element from the circular queue. Return true if the operation is successful. */
    public boolean deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        size--;
        return true;
    }

    /** Get the front item from the queue. */
    public int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[front];
    }

    /** Get the last item from the queue. */
    public int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return data[(rear - 1 + capacity) % capacity];
    }

    /** Checks whether the circular queue is empty or not. */
    public boolean isEmpty() {
        return size == 0;
    }

    /** Checks whether the circular queue is full or not. */
    public boolean isFull() {
        return size == capacity;
    }

    public static void main(String[] args) {
        MyCircularQueue circularQueue = new MyCircularQueue(3); // Set the size to be 3
        System.out.println(circularQueue.enQueue(1));  // return true
        System.out.println(circularQueue.enQueue(2));  // return true
        System.out.println(circularQueue.enQueue(3));  // return true
        System.out.println(circularQueue.enQueue(4));  // return false, the queue is full
        System.out.println(circularQueue.Rear());      // return 3
        System.out.println(circularQueue.isFull());    // return true
        System.out.println(circularQueue.deQueue());   // return true
        System.out.println(circularQueue.enQueue(4));  // return true
        System.out.println(circularQueue.Rear());      // return 4
    }
}
```

### Summary:

- **Problem 862**: Use a deque to maintain the indices of potential maximum values in the sliding window.
- **Problem 641**: Implement a circular deque using an array and pointers to manage front and rear.
- **Problem 622**: Implement a circular queue using an array and pointers to manage front and rear.
