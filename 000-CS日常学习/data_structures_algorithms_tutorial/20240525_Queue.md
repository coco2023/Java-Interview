
### 239. 滑动窗口最大值 (Sliding Window Maximum)

This problem requires finding the maximum value in each sliding window of size `k` in an array.

#### Solution:
```java
import java.util.Deque;
import java.util.LinkedList;

public class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || k <= 0) {
            return new int[0];
        }
        int n = nums.length;
        int[] result = new int[n - k + 1];
        int ri = 0;

        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < nums.length; i++) {
            // Remove indices that are out of the current window
            while (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            // Remove elements that are smaller than the current element
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            // Add current element at the end of the deque
            deque.offer(i);
            // The first element in the deque is the largest element for the current window
            if (i >= k - 1) {
                result[ri++] = nums[deque.peek()];
            }
        }
        return result;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] nums = {1,3,-1,-3,5,3,6,7};
        int k = 3;
        int[] result = solution.maxSlidingWindow(nums, k);
        for (int num : result) {
            System.out.print(num + " ");  // Output: 3 3 5 5 6 7
        }
    }
}
```

### 232. 用栈实现队列 (Implement Queue using Stacks)

This problem requires implementing a queue using two stacks.

#### Solution:
```java
import java.util.Stack;

class MyQueue {
    private Stack<Integer> stack1;
    private Stack<Integer> stack2;

    /** Initialize your data structure here. */
    public MyQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }

    /** Push element x to the back of queue. */
    public void push(int x) {
        stack1.push(x);
    }

    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }

    /** Get the front element. */
    public int peek() {
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.peek();
    }

    /** Returns whether the queue is empty. */
    public boolean empty() {
        return stack1.isEmpty() && stack2.isEmpty();
    }

    public static void main(String[] args) {
        MyQueue myQueue = new MyQueue();
        myQueue.push(1);
        myQueue.push(2);
        System.out.println(myQueue.peek()); // returns 1
        System.out.println(myQueue.pop());  // returns 1
        System.out.println(myQueue.empty()); // returns false
    }
}
```

### 387. 字符串中的第一个唯一字符 (First Unique Character in a String)

This problem requires finding the first unique character in a string and returning its index.

#### Solution:
```java
import java.util.HashMap;
import java.util.Map;

public class Solution {
    public int firstUniqChar(String s) {
        Map<Character, Integer> countMap = new HashMap<>();
        Map<Character, Integer> countMap = new HashMap<>();        
        for (char c : s.toCharArray()) {
            countMap.put(c, countMap.getOrDefault(c, 0) + 1);
        }
        for (int i = 0; i < s.length(); i++) {
            if (countMap.get(s.charAt(i)) == 1) {
                return i;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        String s = "loveleetcode";
        System.out.println(solution.firstUniqChar(s)); // returns 2
    }
}
```

### 225. 用队列实现栈 (Implement Stack using Queues)

This problem requires implementing a stack using two queues.

#### Solution:
```java
import java.util.LinkedList;
import java.util.Queue;

class MyStack {
    private Queue<Integer> queue1;
    private Queue<Integer> queue2;

    /** Initialize your data structure here. */
    public MyStack() {
        queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }

    /** Push element x onto stack. */
    public void push(int x) {
        queue1.add(x);
        while (!queue2.isEmpty()) {
            queue1.add(queue2.poll());
        }
        Queue<Integer> temp = queue1;
        queue1 = queue2;
        queue2 = temp;
    }

    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        return queue2.poll();
    }

    /** Get the top element. */
    public int top() {
        return queue2.peek();
    }

    /** Returns whether the stack is empty. */
    public boolean empty() {
        return queue2.isEmpty();
    }

    public static void main(String[] args) {
        MyStack myStack = new MyStack();
        myStack.push(1);
        myStack.push(2);
        System.out.println(myStack.top());  // returns 2
        System.out.println(myStack.pop());  // returns 2
        System.out.println(myStack.empty()); // returns false
    }
}
```

### 1696. 跳跃游戏 VI (Jump Game VI)

This problem requires finding the maximum score you can get by jumping from the start to the end of the array, given you can jump at most `k` steps forward.

#### Solution:
```java
import java.util.Deque;
import java.util.LinkedList;

public class Solution {
    public int maxResult(int[] nums, int k) {
        int n = nums.length;
        Deque<Integer> deque = new LinkedList<>();
        deque.offer(0);
        for (int i = 1; i < n; i++) {
            nums[i] += nums[deque.peek()];
            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
                deque.pollLast();
            }
            deque.offer(i);
            if (i - deque.peek() >= k) {
                deque.poll();
            }
        }
        return nums[n - 1];
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] nums = {1, -1, -2, 4, -7, 3};
        int k = 2;
        System.out.println(solution.maxResult(nums, k)); // returns 7
    }
}
```

