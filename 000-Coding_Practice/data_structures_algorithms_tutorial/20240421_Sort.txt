/**
https://www.geeksforgeeks.org/adaptive-and-non-adaptive-sorting-algorithms/
https://www.geeksforgeeks.org/in-place-algorithm/

*  In-Place Sorting & Not-In-Place
**/ 
// In-Place Sorting sort the data within the same array
class InsertionSort {
          public void sort (int[] array) {
                    for (int i = 1; i < array.length; i++) {
                              int temp = array[i];
                              int j = i - 1;
                              while (array[j] > temp && j >= 0) {
                                        array[j + 1] = array[j];
                                        j--;
                              }
                              array[j + 1] = temp;
                    }
          }

          public static void main (String[] args) {
                    int[] myArray = {7, 9, 5, 1, 4, 2};
                    sort(myArray);
          }
}

// Not-In-Place Sorting may use additional memory to the input array size for sorting data. This often involves creating an additional array or data structure
class MergeSort {
          public void sort (int[] array) {
                    if (array.length < 2) return;

                    int mid = array.length / 2;
                    int[] left = new int[mid];
                    int[] right = new int[array.length - mid];

                    // copy elements to the left subarray
                    for (int i = 0; i < mid; i++) left[i] = array[i];

                    // copy elements to the right subarray
                    for (int i = mid; i < length; i++) right[i - mid] = array[i];

                    sort(left);
                    sort(right);

                    merge(array, left, right);
          }

          private void merge (int[] result, int[] left, int[] right) {
                    int i = 0, j = 0, k = 0;
                    while (i < left.length && j < right.length) {
                              if (left[i] < right[j]) result[k++] = left[k++];
                              else result[k++] = right[j++];
                    }
                    while (i < left.length) {
                              result[k++] = left[i++];
                    }
                    while (j < right.length) {
                              result[k++] = right[j++];
                    }
          }
}

/**
*  Stable and Not Stable Sorting
**/ 
// This is crucial in scenarios like sorting a list of employees first by department, and then by name, where you want the names to stay in their original order within each department post sorting.
class BubbleSort {
          public void sort (int[] array) {
                    boolean swapped;
                    int n = array.length;

                    do {
                              swapped = false;
                              for (int i = 1; i < n; i++) {
                                        if (array[i - 1] > array[i]) {
                                                  // swap elements
                                                  int temp = array[i - 1];
                                                  array[i - 1] = array[i];
                                                  array[i] = temp;
                                                  swapped = true;
                                        }
                              }
                              n--;
                    } while (swapped == true);
          }
}

// A non-stable sorting algorithm does not guarantee the preservation of the relative order of equal elements. One common non-stable sorting algorithm is Quick Sort.
class QuickSort {
          public void sort (int[] array) {
                    quickSort(array, 0, array.length - 1);
          }

          private void quickSort (int[] array, int low, int high) {
                    if (low < high) {
                              System.out.println("Calling sort with low=" + low + " high=" + high);
                              int pivot = partition(array, low, high);
                              quickSort(array, low, pivot - 1);
                              quickSort(array, pivot + 1, high);
                    }
          }

          private int partition (int[] array, int low, int high) {
                    int pivot = array[high];                // The pivot element is chosen to be the last element of the subrange
                    int i = (low - 1);                      // Index of smaller element
                    System.out.println("\nPartitioning with pivot=" + pivot + " low=" + low + " high=" + high);

                    for (int j = low; j < high; j++) {      // Iterate over the array from the 'low' to 'high-1'
                              System.out.println("Comparing nums[" + j + "]=" + array[j] + " with pivot=" + pivot);

                              if (array[j] < pivot) {       // If current element is smaller than the pivot
                                        i++;                // move the index of the smaller element forward
                                        System.out.println("  nums[" + j + "] < pivot, increment i=" + i);

                                        int temp = array[i];
                                        array[i] = array[j];
                                        array[j] = temp;
                                        System.out.println("  Swapped nums[" + i + "]=" + array[i] + " with nums[" + j + "]=" + array[j]);
                              }
                    }
                    int temp = array[i + 1];
                    array[i + 1] = array[high];
                    array[high] = temp;
                    System.out.println("Swapped pivot with nums[" + (i + 1) + "]=" + array[i + 1] + ", new pivot index=" + (i + 1));

                    return i + 1;
          }

          public static void main (String[] args) {
                    int[] array = {10, 7, 8};
                    QuickSort sorter = new QuickSort();
                    sorter.sort(array, 0, array.length - 1);
                    for (int num : array) {
                              System.out.println(num + " ");
                    } 
          }

/**
Step 1 − Choose the highest index value has pivot 
Step 2 − Take two variables to point left and right of the list excluding pivot 
Step 3 − left points to the low index 
Step 4 − right points to the high 
Step 5 − while value at left is less than pivot move right 
Step 6 − while value at right is greater than pivot move left 
Step 7 − if both step 5 and step 6 does not match swap left and right 
Step 8 − if left ≥ right, the point where they met is new pivot
**/

/** Output
Calling sort with low=0 high=2

Partitioning with pivot=8 low=0 high=2
Comparing nums[0]=10 with pivot=8
Comparing nums[1]=7 with pivot=8
  nums[1] < pivot, increment i=0
  Swapped nums[0]=7 with nums[1]=10
Swapped pivot with nums[1]=8, new pivot index=1

Calling sort with low=0 high=0

Calling sort with low=2 high=2

Sorted array:
7 8 10 
**/
}

// Selection Sort
class SelectionSort {
          public void sort (int[] array) {
                    int n = array.length;

                    for (int i = 0; i < n - 1; i++) {
                              int min_index = i;
                              for (int j = i + 1; j < n; j++) {
                                        if (array[j] < array[min_index]) min_index = j;
                              }

                              int temp = array[min_index];
                              array[min_index] = array[i];
                              array[i] = temp; 
                    }
          }
}

// Heap Sort
class HeapSort {
          public void sort (int[] array) {
                    int n = array.length;

                    // Build heap (rearrange array)
                    for (int i = n / 2 - 1; i >= 0; i--) {
                              heapify(array, n, i);
                    }

                    // One by one extract an element from heap
                    for (int i = n - 1; i > 0; i--) {
                              // Move current root to end
                              int temp = array[0];
                              array[0] = array[i];
                              array[i] = temp;

                              heapify(array, i, 0);
                    }
          }

          private void heapify (int[] array, int n, int i) {
                    int largest = i;
                    int left = 2 * i + 1;
                    int right = 2 * i + 2;

                    if (left < n && array[left] > array[largest]) largest = left;
                    if (right < n && array[right] > array[largest]) largest = right;
                    if (largest != i) {
                              int swap = array[i];
                              array[i] = array[largest];
                              array[largest] = swap;

                              heapify(array, n, largest);
                    }
          }
}