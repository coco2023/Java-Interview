class BinarySearchTree {
          TreeNode root;

          class TreeNode {
                    int data;
                    TreeNode left;
                    TreeNode right;

                    TreeNode (int data) {
                              this.data = data;
                              this.left = null;
                              this.right = null;
                    }
          }

          public BinarySearchTree () {
                    this.root = null;
          }

          // insert
          public void insert (int data) {
                    root = insertRec(root, data);
          }

          private TreeNode insertRec (TreeNode root, int data) {
                    if (root == null) {
                              root = new TreeNode(data);
                              return root;
                    }
                    if (data < root.data) {
                              root.left = insertRec(root.left, data);
                    } else if (data > root.data) {
                              root.right = insertRec(root.right, data);
                    }
                    return root;
          }

          // Iteratively insert a new element into the BST
          public void insert (int data) {
                    TreeNode newNode = new TreeNode(data);
                    if (root == null) {
                              root = newNode;
                              return;
                    }
                    TreeNode curr = root;
                    TreeNode parent = null;
                    while (true) {
                              parent = curr;
                              if (data < curr.data) {
                                        curr = curr.left;
                                        if (curr == null) {
                                                  parent.left = newNode;
                                                  return;
                                        }
                              } else {
                                        curr = curr.right;
                                        if (curr == null) {
                                                  parent.right = newNode;
                                                  return;
                                        }
                              }
                    }
          }

          // search
          public boolean search (int data) {
                    return searchRec(root, data);
          }

          private boolean searchRec (TreeNode root, int data) {
                    if (root == null) return false;
                    if (root.data == data) return true;

                    if (data < root.data) { // left
                              searchRec(root.left, data);
                    } else { // right
                              searchRec(root.right, data);
                    }
                    return false;
          }

          // Iteratively search for an element in the BST
          public void search (int data) {
                    if (root == null) return false;

                    TreeNode curr = root;
                    while (curr != null) {
                              if (curr.data == data) return true;
                              else if (data < curr.data) curr = curr.left;
                              else if (data > curr.data) curr = curr.right;
                    }
                    return false;
          }

          // in-order (recursive)
          public void inOrder (TreeNode root) {
                    if (root == null) return;

                    inOrder(root.left);
                    System.out.println(root.data);
                    inOrder(root.right);
          }

          // pre-order (recursive)
          public void preOrder (TreeNode root) {
                    if (root == null) return;

                    System.out.println(root.data);
                    preOrder(root.left);
                    preOrder(root.right);
          }

          // post-order (recursive)
          public void postOrder () {
                    if (root == null) return;

                    postOrder(root.left);
                    postOrder(root.right);
                    System.out.println(root.data);
          }

          // in-order (lteratively)
          public void inOrder (TreeNode root) {
                    if (root == null) return null;

                    Stack<TreeNode> stack = new Stack<>();
                    TreeNode curr = root;

                    while (curr != null || !stack.isEmpty()) {
                              while (curr != null) {
                                        stack.push(curr);
                                        curr = curr.left;
                              }
                              curr = stack.pop();
                              System.out.println(curr.data);
                              curr = curr.right;
                    }
          }

          // pre-order (lteratively)
          public void preOrder (TreeNode root) {
                    if (root == null) return;

                    Stack<TreeNode> stack = new Stack<>();
                    stack.push(root);

                    while (!stack.isEmpty()) {
                              TreeNode node = stack.pop();
                              System.out.println(node.data);

                              if (node.right != null) stack.push(node.right);   // push right first so that ensure left pop first
                              if (node.left != null) stack.push(node.left);
                    }
          }

          // post-order (lteratively)
          public void postOrder (TreeNode root) {
                    if (root == null) return;

                    Stack<TreeNode> stack1 = new Stack<>();
                    Stack<TreeNode> stack2 = new Stack<>();
                    stack1.push(root);

                    while (!stack1.isEmpty()) {
                              TreeNode node = stack1.pop();
                              stack2.push(node); // first direct push root to stack2
                              if (node.left != null) stack1.push(node.left);   
                              if (node.right != null) stack1.push(node.right); // right is on the top, faster push into stack2 than left; later than stack1 to be pop;
                    }

                    while (!stack2.isEmpty()) {
                              TreeNode node = stack2.pop();
                              System.out.println(node.data);
                    }
          }

          public static void main (String[] args) {
                    BinarySearchTree bst = new BinarySearchTree();
                    bst.root = new TreeNode(10);
                    bst.root.left = new TreeNode(8);
                    bst.root.right = new TreeNode(15);

                    bst.root.left.left = new TreeNode(6);
                    bst.root.left.right = new TreeNode(9);

                    bst.root.right.left = new TreeNode(14);
                    bst.root.right.right = new TreeNode(20);
          }

}

class AVLTree {
          AVLTreeNode root;

          class AVLTreeNode {
                    int data;
                    AVLTreeNode left;
                    AVLTreeNode right;
                    int height;

                    AVLTreeNode(int data) {
                              this.data = data;
                              this.left = null;
                              this.right = null;
                              this.height = 1;
                    }
          }

          private int height (AVLTreeNode N) {
                    if (N == null) return 0;
                    return N.height;
          }

          // Right rotate subtree rooted with y
          private AVLTreeNode rightRotate (AVLTreeNode y) {
                    AVLTreeNode x = y.left;
                    AVLTreeNode T2 = x.right;

                    // perform rotation
                    x.right = y;
                    y.left = T2;

                    // Update heights
                    y.height = Math.max(height(y.left), height(y.right)) + 1;
                    x.height = Math.max(height(x.left), height(x.right)) + 1;

                    // return new root
                    return x;
          }

          // Left rotate subtree rooted with x
          private AVLTreeNode leftRotate (AVLTreeNode x) {
                    AVLTreeNode y = x.right;
                    AVLTreeNode T2 = y.left;

                    // rotation
                    y.left = x;
                    x.right = T2;

                    // update heights
                    x.height = Math.max(height(x.left), height(x.right)) + 1;
                    y.height = Math.max(height(y.left), height(y.right)) + 1;

                    // return new root
                    return y;
          }

          private AVLTreeNode leftRightRotate (AVLTreeNode node) {
                    node.left = leftRotate(node.left);
                    return rightRotate(node);
          }

          private AVLTreeNode rightLeftRotate (AVLTreeNode node) {
                    node.right = rightRotate(node.right);
                    return leftRotate(node);
          }

          public void preOrder (AVLTreeNode root) {
                    if (root == null) return;
                    
                    System.out.println(root.data);
                    preOrder(root.left);
                    preOrder(root.right);
          }

          // AVL Tree Check
          public boolean isAVLTree (AVLTreeNode root) {
                    return isAVLTreeHelper(root) != -1;
          }

          private int isAVLTreeHelper (AVLTreeNode node) {
                    if (node == null) return 0;

                    int leftHeight = isAVLTreeHelper(node.left);
                    if (leftHeight == -1) return -1;

                    int rightHeight = isAVLTreeHelper(node.right);
                    if (rightHeight == -1) return -1;

                    if (Math.abs(leftHeight - rightHeight) > 1) return -1;

                    node.height = Math.max(leftHeight, rightHeight) + 1;
                    return node.height;  // Return the height if subtree is AVL
          }

          // Utility function to get the balance factor of the node N
          private int getBalance (AVLTreeNode N) {
                    if (N == null) return 0;
                    return height(N.left) - height(N.right);
          }

          // Insert a new key in the subtree rooted with node and returns the new root of the subtree.
          public AVLTreeNode insert (AVLTreeNode node, int data) {
                    // 1. Perform the normal BST insertion
                    if (node == null) return new AVLTreeNode(data);

                    if (data < node.data) node.left = insert(node.left, data);
                    else if (data > node.data) node.right = insert(node.right, data);
                    else return node;                       // Duplicate data not allowed

                    // 2. Update height of this ancestor node
                    node.height = 1 + Math.max(height(node.left), height(node.right));

                    // 3. Get the balance factor of this ancestor node to check whether this node became unbalanced
                    int balance = getBalance(node);

                    // If this node becomes unbalanced, then there are 4 cases
                    
                    // Left Left Case
                    if (balance > 1 && data < node.left.data) return rightRotate(node);

                    // Right Right Case
                    if (balance < -1 && data > node.right.data) return leftRotate(node);

                    // Left Right Case
                    if (balance > 1 && data > node.left.data) leftRightRotate(node);

                    // Right Left Case
                    if (balance < -1 && data < node.right.data) rightLeftRotate(node);

                    return node;
          }

          public static void main (String[] args) {
                    AVLTree tree = new AVLTree();
                    tree.root = tree.insert(tree.root, 10);
                    tree.root = tree.insert(tree.root, 20);
                    tree.root = tree.insert(tree.root, 30);
                    tree.root = tree.insert(tree.root, 40);
                    tree.root = tree.insert(tree.root, 50);
                    tree.root = tree.insert(tree.root, 25);

                    tree.preOrder(tree.root);
          }
}


